<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[css世界--流、元素、基本尺寸]]></title>
    <url>%2F2018%2F10%2F22%2Fcss%E4%B8%96%E7%95%8C-%E6%B5%81%E3%80%81%E5%85%83%E7%B4%A0%E3%80%81%E5%9F%BA%E6%9C%AC%E5%B0%BA%E5%AF%B8%2F</url>
    <content type="text"><![CDATA[最近在读张鑫旭大神的CSS世界一书，收货很多，记录下的读书笔记。 流 元素 基本尺寸 流之所以影响整个css世界，是因为它影响了css世界的基石 –HTML HTML 常见的标签有div、 p、 li和table以及span、 img、 strong和em等。虽然标签种类繁多，但通常我们就把它们分为两类： 块级元素（block-level element）和内联元素（inline element）。 1.块级元素1.1 概念相关“块级元素”对应的英文是 block-level element，常见的块级元素有 div,li,table等。 块级元素和 display：block 不是一个概念 例如块级元素 li 和 table ，他们的 display 的值分别为 list-item 和 table 块级元素具有换行性质，也就是一个水平流上只能单独显示一个元素，多个块级元素则换行显示； 由于这种 换行性质，理论上块级元素都可以配合 clear 属性来清除浮动带来的影响 12345.clear:after &#123; content: ''; display: table; // 也可以是 block，或者是 list-item clear: both;&#125; 实际开发中，display的值要么是block，要么是table，并不会使用list-item 1.2 为什么 list-item会出现项目符号 所有的块级元素都有一个主盒子，而list-item除了主盒子，还有一个附加盒子 list-item 之所以会出现项目符号(小黑点)，是因为生成了一个附加盒子，学名为 “标记盒子”，专门来存放圆点，数字这些项目符号 IE不支持display：list-item 的原因可能就是因为IE无法创建 这个标记盒子的原因。 1.3 display:inline-blockdisplay:inline-block 我们可以把一个这样的元素分为两个部分组成，外在的inline内联盒子，里面的block块级盒子组成。这样，由于外在的外联盒子，它的呈现方式既可以和文字等元素同为一行，又因为内在的块级盒子，它可以设置元素的宽高。 于是，按照display的属性值不同 display 外盒子 内盒子 block block block inline inline inline inline-block inline block table block table inline-table inline table 外盒子影响着流的走向，内盒子控制元素的基本属性 2. width/height 作用的具体细节 我们在上面已经说过， width/height等属性作用在内盒子中，也就是容器盒子中。接下来我们说一下具体的作用细节。 流特性体现在水平方向上，我们来讨论width 2.1 width:auto width的默认值就是auto 充分利用空间 – div的默认宽度一般都是100% 收缩和包裹 收缩到最小 – min-content 当每一列空间都不够的时候，文字能断就断，但中文是随便断的，英文单词不能断。 超出容器限制 没有相关设置的情况下，一般元素不会主动超过父级宽度容器，除非一些特殊情况 例如：内容而很长的连续英文和数字 ​ 或者内联元素被设置了 white-space:nowrap 属性 在 CSS 世界中，盒子分“内在盒子”和“外在盒子”，显示也分“内部显示”和“外部显示”，同样地，尺寸也分“内部尺寸”和“外部尺寸”。 上述的width：auto 的四条特性里面，是默认宽度 100%显示，是“外部尺寸”，其余全部是“内部尺寸”。而这唯一的“外部尺寸”，是“流”的精髓所在。 2.2 外部尺寸与流体特性 正常流宽度。 当我们在一个容器里倒入足量的水时，水一定会均匀铺满整个容器。 1234a &#123; display: block; width: 100%;&#125; 默认为inline的a元素display设置为block，本身就是表示宽度铺满整个父级，后面的100%宽度就不用再加了。 作者总结过一套三无准则: 无宽度，无图片，无浮动。 其中无宽度的原因就是因为一旦外部尺寸的块级元素设置了宽度，其流动性就丢失了。 格式化宽度 格式化宽度仅出现在“绝对定位模型”中，也就是出现在 position属性值为 absolute 或 fixed 的元素中。在默认情况下，绝对定位元素的宽度表现是“包裹性”，宽度由内部尺寸决定 但是有一种情况其宽度是由外部尺寸所决定的，例如： 1div &#123; position: absolute; left: 20px; right: 20px; &#125; 假设该元素最近的具有定位特性的祖先元素的宽度是 1000 像素，则这个元素的宽度是 960（即 1000−20−20）像素。 2.3 内部尺寸与流体特性 所谓“内部尺寸”，简单来讲就是元素的尺寸由内部的元素决定，而非由外部的容器决定。 如何判断一个元素是否为内部尺寸呢？ ​ 假如这个元素里面没有内容，宽度就是 0，那就是应用的“内部尺寸”。 “内部尺寸”有下面 3 种表现形式： 包裹性。 “包裹性”，除了“包裹”，还有“自适应性”。“自适应性”是区分后面两种尺寸表现很重要的一点。自适应，指的是元素尺寸由内部元素决定。 按钮就是 CSS 世界中极具代表性的 inline-block 元素，可谓展示“包裹性”最好的例子，具体表现为：按钮文字越多宽度越宽（内部尺寸特性），但如果文字足够多，则会在容器的宽度处自动换行（自适应特性）。 “包裹性”对实际开发的作用 请看这个需求：页面某个模块的文字内容是动态的，可能是几个字，也可能是一句话。然后，希望文字少的时候居中显示，文字超过一行的时候居左显示。该如何实现？ 官方演示代码连接 首选最小宽度 在 CSS 世界中，图片和文字的权重要远大于布局，因此，CSS 的设计者显然是不会让图文在 width:auto 时宽度变成 0 的，此时所表现的宽度就是“首选最小宽度”。 汉字最小宽度是每个字的宽度 英文最小宽度是由连续的英文字符单元决定，终止于空格，短横线及其他非字母符号 想让英文字符和中文一样一个字符为最小宽度，可以使用css中的 word-break:break-all 属性 类似图片这样的替换元素的最小宽度就是该元素内容本身的宽度 最大宽度 最大宽度就是元素可以有的最大宽度。 如果内部没有块级元素或者块级元素没有设定宽度值，则“最大宽度”实际上是最大的连续内联盒子的宽度。 2.4 width 值作用的细节 对于一个元素，我们设定其宽度为 100px，如下：div { width: 100px; }请问，100px 的宽度是如何作用到这个元素上的？ width 是作用在“内在盒子”上的,实际上，这个内在盒子是由很多部分组成 — 盒子模型 我们的这个“内在盒子”又被分成了 4 个盒子，分别是 content box、padding box、border box和 margin box “margin 的背景永远是透明的”，因此不可能作为 backgound-clip 或 backgroundorigin属性值出现。margin 一旦设定具体宽度和高度值，其本身的尺寸是不会因 margin值变化而变化的。 width宽度作用在content盒子上 假设一个盒子的css如下： 1div &#123; width: 100px; padding: 20px; border: 20px solid; &#125; 那么它的宽度就变成了 100 + 20x2 + 20x2 = 180 px 了 合情合理，但是这种机制会导致以下问题： 流动性丢失 与现实世界表现不一致的困扰 有没有什么办法能避免这种盒子计算而导致的错位问题呢，方法之一就是采用书写方式约束，使用“宽度分离原则” 2.4 CSS流体布局下的宽度分原则 所谓“宽度分离原则”，就是 CSS 中的 width 属性不与影响宽度的 padding/border（有时候包括 margin）属性共存 如何实现？ 分离，width 独立占用一层标签，而padding、border、margin 利用流动性在内部自适应呈现。 例子： 这里有一个div盒子 常规布局 1234.box &#123; width: 100px; border: 1px solid;&#125; 此时宽度为102像素，我们现在希望元素内边框有20像素的留白，我们一般会想到的解决办法是加padding的值 12345.box &#123; width: 100px; padding: 20px; border: 1px solid;&#125; ok 此时有了留白，但是我们发现宽度变成了 102 + 40 = 142px, 我们常规的会使用减少宽度来实现我们的要求 12345.box &#123; width: 60px; // 通过计算，减去 40 像素 padding: 20px; border: 1px solid;&#125; 要求实现了，但是如果我们是通过计算，才能达到我们想要的，以后的调试会有更多的麻烦。 宽度分离 1234567.father &#123; width: 102px;&#125;.son &#123; border: 1px solid; padding: 20px;&#125; 嵌套一层标签，父元素定宽，子元素因为 width 使用的是默认值 auto，所以会如水流般自动填满父级容器。 宽度还是 102 像素，子元素的 content box 自动变成了 60 像素，和上面反例的表现一样。 也就是说，使用“宽度分离”后，咱们不需要烧脑子去计算了，而且页面结构反而更稳固。 这个做法的唯一缺点就是要多嵌套一层html标签，和对开发者极高的css要求水平。 &gt; 针对这中情况，有没有即无需计算，又不用额外的套用标签而实现呢？ ----&gt; box-sizing 2.5 改变width/height 作用细节的 box-sizingbox-sizing 被直译为“盒尺寸”，实际上，其更准确的叫法应该是“盒尺寸的作用细节”，或者说得更通俗一点，叫“width 作用的细节”，也就是说，box-sizing 属性的作用是改变 width 的作用细节。 正常情况下width作用在盒模型中的四个盒子中的content盒子上，box-sizing的作用就是可以把width作用的盒子变成其他的几个盒子上，有以下几种写法 1234.box1 &#123; box-sizing: content-box; &#125; /* 默认值 */.box2 &#123; box-sizing: padding-box; &#125; /* Firefox 曾经支持 */.box3 &#123; box-sizing: border-box; &#125; /* 全线支持 */.box4 &#123; box-sizing: margin-box; &#125; /* 从未支持过 */ 拿 .box3 { box-sizing: border-box; }来说，就是把原来的宽度作用对象从content-box转到了border-box 123456789101112.box &#123; width: 100px; box-sizing: border-box;&#125; 此时这个盒子的宽度是100px.box &#123; width: 100px; box-sizing: border-box; border: 1px solid;&#125; 这事的宽度还是100px 2.6 height: auto 和 height: 100% 宽度稀缺，高度无限，所以在css中高度较宽度更简单纯洁 height: auto 所有的元素盒子在页面中表现的每个有多高，加在一起，就是最终的高度值 height: 100% height 和 width 还有一个比较明显的区别就是对百分比单位的支持。对于 width 属性，就算父元素 width 为 auto，其百分比值也是支持的，但是对于 height 属性，如果父元素height 为 auto，只要子元素在文档流中，其百分比值完全就被忽略了。 对于普通文档流中的元素，百分比高度值要想起作用，其父级必须有一个可以生效的高度值。 为何父级没有具体高度值的时候，height:100%会无效？ 如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为auto。一句话总结就是：因为解释成了 auto。要知道，auto 和百分比计算，肯定是算不了的。 如何让元素支持 height:100%效果 设定显式的高度值。这个没什么好说的，例如，设置 height:600px，或者可以生效的百分比值高度。 123html, body &#123; height: 100%;&#125; 使用绝对定位。 1234div &#123; height: 100%; position: absolute;&#125; 此时的 height:100%就会有计算值，即使祖先元素的 height 计算为 auto 也是如此。 绝对定位元素的百分比计算和非绝对定位元素的百分比计算是有区别的: 绝对定位的宽高百分比计算是相对于 padding box 的 非绝对定位元素则是相对于 content box 计算的 3. min-width/max-width和min-height/max-height3.1为流体而生的 min-width/max-width 网页宽度在 1200～1400 像素自适应，既满足大屏的大气，又满足笔记本的良好显示 1234.container &#123; min-width: 1200px; max-width: 1400px;&#125; 无须 width 设置，直接使用 min-width/max-width 再比如一个图片的盒子宽度已定： 1234img &#123; max-width: 100%; height: auto!important;&#125; height:auto 是必需的，否则，如果原始图片有设定 height，max-width 生效的时候，图片就会被水平压缩。强制 height 为 auto 可以确保宽度不超出的同时使图片保持原来的比例。但这样也会有体验上的问题，那就是在加载时图片占据高度会从 0 变成计算高度，图文会有明显的瀑布式下落。 3.2 与众不同的初始值 width/height 的默认值是 auto，而 min-width/max-width 和 min-heigh/max-height 的初始值则要复杂些 max-width 和 max-height 的初始值是 none min-width 和 min-height 的初始值是 auto 3.3 超越!important，超越最大超越!important min-width/max-width 和 min-height/max-height 属性间，以及与width 和 height 之间有一套相互覆盖的规则。这套规则用一句比较通俗的话概括就是:超越!important，超越最大。 12&lt;img src="1.jpg" style="width:480px!important;"&gt;img &#123; max-width: 256px; &#125; 以上代码作用后，img的宽度为 max-width的宽度 – 256px，style、!important 通通靠边站！因为 max-width 会覆盖 width。 超越最大 1234.container &#123; min-width: 1400px; max-width: 1200px; &#125; 最小宽度居然比最大宽度设置得还大, 最后谁会生效？ 遵循“超越最大”规则（注意不是“后来居上”规则），min-width 活下来，max-width 被忽略，于是，.container 元素表现为至少 1400 像素宽 3.4 任意高度元素的展开收起动画技术 “展开收起”效果是网页中比较常见的一种交互形式，通常的做法是控制 display 属性值在 none 和其他值之间切换 传统实现可以使用 jQuery 的 slideUp()/slideDown()方法 第一反应就是使用 height + overflow:hidden 实现。但是，很多时候，我们展开的元素内容是动态的，换句话说高度是不固定的，因此，height 使用的值是默认的 auto 因此，下面代码呈现的效果也是生硬地展开和收起： 12345678.element &#123; height: 0; overflow: hidden; transition: height .25s;&#125;.element.active &#123; height: auto; /* 没有 transition 效果，只是生硬地展开 */&#125; auto 是个关键字值，并非数值，正如 height:100%的 100%无法和 auto 相计算一样，从 0px 到 auto 也是无法计算的，因此无法形成过渡或动画效果。 我们可以使用max-height来解决这一问题 12345678.element &#123; max-height: 0; overflow: hidden; transition: max-height .25s;&#125;.element.active &#123; max-height: 666px; /* 一个足够大的最大高度值 */&#125; 展开后我的高度只要比max-height小，那么元素的高度就是height的计算高度，一个高度不定的任意元素的展开动画效果就能实现了。 css世界官方demo 注意： max-height值在保证比height大的情况下尽可能和的小 因为max-height可能会影响动画的时间， 比方说，我们展开的元素高度是 100 像素，而 max-height 是 1000 像素，假如一个动画1000ms，则前 900 ms 我们是看不到收起效果的，因为max-height 从 1000 像素到 100 像素变化这段时间，元素不会有区域被隐藏，会给人动画延迟 900 ms 的感觉 4. 内联元素4.1 哪些是内联元素从定义： 内联元素的内联指的是外在盒子，外在盒子表现为inline的元素都是内联元素。 inline-block 和 inline-table 都是“内联元素”，因为它们的“外在盒子”都是内联盒子。自然 display:inline 的元素也是“内联元素”，那么，按钮元素是内联元素，因为其 display 默认值是 inline-block；img图片元素也是内联元素，因为其 display 默认值是 inline 等。 从表现看: 就行为表现来看，“内联元素”的典型特征就是可以和文字在一行显示。 浮动元素貌似也是可以和文字在一个水平上显示的,但是浮动已经脱离文档流，不属于内联元素。 4.2 内联世界深入的基础—内联盒模型 (import)1&lt;p&gt;这是一行普通的文字，这里有个 &lt;em&gt;em&lt;/em&gt; 标签。&lt;/p&gt; 看似普通，实际上包含了很多术语和概念，或者换种通俗的说法，包含了很多种盒子。 内容区域 内容区域指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个字符盒子（character box）；但是有些元素，如图片这样的替换元素，其内容显然不是文字，不存在字符盒子之类的，因此，对于这些元素，内容区域可以看成元素自身。 1这是一行普通的文字，这里有个 &lt;em&gt;em&lt;/em&gt; 标签。 以上代码表现的区域，可以理解为内容区域。 内联盒子 如果外部含内联标签等），则属于“内联盒子”；如果是个光秃秃的文字，则属于“匿名内联盒子” 行框盒子（line box） 每一行就是一个“行框盒子”（实线框标注），每个“行框盒子”又是由一个一个“内联盒子”组成的。 包含盒子/包含块（containing box） &lt;p&gt;标签就是一个“包含盒子”（实线框标注），此盒子由一行一行的“行框盒子”组成。 4.3 幽灵空白节点 在 HTML5 文档声明中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵一样，但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点” 1234567891011&lt;style&gt; div &#123; background-color: #cd0000; &#125; span &#123; display: inline-block; &#125;&lt;/style&gt;&lt;body&gt; &lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/body&gt; 浏览器打开上述代码，发现div的高度不是0，原因就在于幽灵空白节点。 “幽灵空白节点”实际上也是一个盒子，不过是个假想盒，名叫“strut”，中文直译为“支柱”，是一个存在于每个“行框盒子”前面，同时具有该元素的字体和行高属性的 0 宽度的内联盒。 Each line box starts with a zero-width inline box with the element’s font and lineheight properties. We call that imaginary box a “strut”. 内容总结与 张鑫旭大神 – 《css世界》]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css世界</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node-blog项目简记]]></title>
    <url>%2F2018%2F10%2F18%2Fnode-blog%E9%A1%B9%E7%9B%AE%E7%AE%80%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[使用node建立了一个node博客系统，数据库使用了mongodb，完成了一整套前后端的交互。github仓库地址： node-blog Node-Blog 后端使用node写的一个一整套的博客系统 主要功能 登录 注册 发表文章 编辑/删除文章 添加/删除/编辑文章分类 账号的管理 评论功能 … 所用技术 node express swig渲染模板 body-parser中间件 cookies mongod(mongoose) 数据库 html css js ajax等 主要页面展示 index 详情页 ​ 后台 一、项目初始化1.1 创建目录├─models 存放数据库数据模型├─public 存放静态资源├─routers 路由文件├─schemas 数据库Schema表└─views 静态页面 │ .gitignore github仓库上传忽略文件│ app.js 主程序入口文件│ package-lock.json│ package.json│ README.md 1.2 装包使用npm安装项目要使用的包 1.3 创建基本app服务1234567891011var express = require('express')var mongoose = require('mongoose')var app = express()// 连接数据库mongoose.connect('mongodb://localhost/node-blog', &#123; useNewUrlParser: true &#125;);app.listen(3000, function () &#123; console.log('http://localhost:3000') &#125;) 二、开发开始2.1 模板使用 swig12345678910111213// 定义模板引擎app.engine('html', swig.renderFile)// 设置模板文件存放目录app.set('views', './views')// 注册模板引擎app.set('view engine', 'html')//设置swig页面不缓存swig.setDefaults(&#123; allowErrors: false, autoescape: true, cache: false&#125;) 2.2 静态文件托管12// 静态文件托管app.use('/public', express.static(__dirname + '/public') 知识点1：在 Express 中提供静态文件 为了提供诸如图像、CSS 文件和 JavaScript 文件之类的静态文件，请使用 Express 中的 express.static 内置中间件函数。 1app.use(express.static('public')); 这样后 我们就可以访问public文件中的任意目录的任意文件： 123http://localhost:3000/images/kitten.jpghttp://localhost:3000/css/style.csshttp://localhost:3000/js/app.js 注意： Express 相对于静态目录查找文件，因此静态目录的名称不是此 URL 的一部分。 可以多次使用static函数开启多个静态资源入口。 自定义文件目录名称 上面的例子中我们可以访问 http://localhost:3000/js/app.js这个目录 但是如果我想通过http://localhost:3000/static/js/app.js来访问，我们可以使用： 1app.use('/static', express.static('public')); 来创建虚拟路径前缀（路径并不实际存在于文件系统中） 当然，在项目中一般使用绝对路径来保证代码的可行性： 1app.use('/static', express.static(__dirname + '/public')); 2.3 连接数据库12// 连接数据库mongoose.connect('mongodb://localhost/node-blog' &#123; useNewUrlParser: true &#125;); mongod会在第一个数据创建的时候新建我们的node-blog数据库，不需要我们手动创建 后面的一个配置项最好加上。不报错的话可不加。 2.4 分模块开发与实现路由 前台模块 main模块 / 首页 / 内容页 后台管理模块 admin模块 API模块 api模块 1234// 路由app.use('/admin', require('./routers/admin'))app.use('/api', require('./routers/api'))app.use('/', require('./routers/main')) 知识点2：express.Router的使用 使用 express.Router 类来创建可安装的模块化路由处理程序。Router 实例是完整的中间件和路由系统；因此，常常将其称为“微型应用程序”。 使用express.Router，可以将路由更加模块化 比如：在 routers文件夹下新建 main.js 12345678910111213var express = require('express')var router = express.Router()...router.get('/', function (req, res, next) &#123; ...&#125;router.get('/view',(req, res) =&gt; &#123; ...&#125; module.exports = router 末尾使用module.exports = router 将router对象暴露出去 我们将其安装在主应用程序app.js的路径中 123...app.use('/', require('./routers/main'))... 此时的 ‘/’ 路径请求的就是 main.js中的 ’/‘ /view –&gt; main.js 中的 ‘/view’ 开发顺序功能模块开发顺序 用户 栏目 内容 评论 编码顺序 Schema 定义存储结构 功能逻辑 页面展示 三、注册 登录 登出3.1 userSchema创建新建并编写 schemas/user.js1234567891011var mongoose = require('mongoose')// 用户表结构module.exports = new mongoose.Schema(&#123; username: &#123; type: String &#125;, password: &#123; type: String &#125;&#125;) 3.2 创建User model1234var mongoose = require('mongoose')var userSchema = require('../schemas/user')module.exports = mongoose.model('User', userSchema) 知识点3：mongoose中的 Schema 和 Model Mongoose 的一切始于 Schema。每个 schema 都会映射到一个 MongoDB collection ，并定义这个collection里的文档的构成 关于schema的官方文档 定义一个schema 123456789101112131415var mongoose = require('mongoose');var Schema = mongoose.Schema;var blogSchema = new Schema(&#123; title: String, author: String, body: String, comments: [&#123; body: String, date: Date &#125;], date: &#123; type: Date, default: Date.now &#125;, hidden: Boolean, meta: &#123; votes: Number, favs: Number &#125;&#125;); 创建一个model 我们要把 schema 转换为一个 Model， 使用 mongoose.model(modelName, schema) 函数： 1var Blog = mongoose.model('Blog', blogSchema); Models 是从 Schema 编译来的构造函数。 它们的实例就代表着可以从数据库保存和读取的 documents。 从数据库创建和读取 document 的所有操作都是通过 model 进行的。 第一个参数是跟 model 对应的集合（ collection ）名字的 单数 形式。 Mongoose 会自动找到名称是 model 名字 复数形式的 collection 。 对于上例，Blog这个 model 就对应数据库中 blogs 这个 collection。.model() 这个函数是对 schema 做了拷贝（生成了 model）。 你要确保在调用 .model() 之前把所有需要的东西都加进 schema 里了 一个model就是创造了一个mongoose实例，我们才能将其操控。 我的片面理解把Schema和model的关系 想成 构造函数和实例之间的关系 3.3 注册注册逻辑 表单验证 数据库验证 前台 ajax 静态页面 处理 前端ajax注册 12345678910111213141516171819202122// 注册$register.find('.user_register_btn').on('click', function () &#123; $.ajax(&#123; type: 'post', url: 'api/user/register', data: &#123; username: $register.find('[name="username"]').val(), password: $register.find('[name="password"]').val(), repassword: $register.find('[name="repassword"]').val() &#125;, dataType: 'json', success: function (result) &#123; $register.find('.user_err').html(result.message) if (!result.code) &#123; setTimeout(() =&gt; &#123; $('.j_userTab span')[0].click() &#125;, 1000) &#125; &#125; &#125;)&#125;) 后台api路由 在api.js中编写后台注册相关代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*注册： 注册逻辑 1. 用户名不能为空 2. 密码不能为空 3. 两次密码一致 数据库查询 1. 用户名是否已经被注册*/router.post('/user/register', function (req, res, next) &#123; var username = req.body.username var password = req.body.password var repassword = req.body.repassword// -------表单简单验证----------- if (username == '') &#123; responseData.code = 1 responseData.message = '不填用户名啊你' res.json(responseData) return &#125; if (password == '') &#123; responseData.code = 2 responseData.message = '密码不填？' res.json(responseData) return &#125; if (password !== repassword ) &#123; responseData.code = 3 responseData.message = '两次密码不一致啊' res.json(responseData) return &#125;// -------------------------------// -------数据库验证验证----------- User.findOne(&#123; username: username &#125;).then((userInfo) =&gt; &#123; if (userInfo) &#123; // 数据库中已有用户 responseData.code = 4 responseData.message = '用户名有了，去换一个' res.json(responseData) return &#125; // 保存用户注册信息 var user = new User(&#123; username: username, password: password &#125;) return user.save() &#125;).then((newUserInfo) =&gt; &#123; responseData.message = '耶~ 注册成功' res.json(responseData) &#125;)// -------------------------------&#125;) 后台通过简单的验证，将结果通过 res.json 的方式来返还给 前台 ajax 再通过json信息来处理页面展示。 ​ 知识点4：使用body-parser中间件来处理post请求 关于express的更多中间件 使用案例 12345678910var express = require('express')var bodyParser = require('body-parser')var app = express()// parse application/x-www-form-urlencodedapp.use(bodyParser.urlencoded(&#123; extended: false &#125;))// parse application/jsonapp.use(bodyParser.json()) 通过以上的配置，我们就可以获取通过 req.body 来获取 post 请求总的参数了 12345... var username = req.body.username var password = req.body.password var repassword = req.body.repassword... 知识点5: mongoose中数据库的操作 前段时间总结过一些mongoose的增删查操作笔记： ​ node中的mongodb和mongoose ​ 3.4 登录 前台ajax 12345678910111213141516171819// 登录 $login.find('.user_login_btn').on('click', function () &#123; $.ajax(&#123; type: 'post', url: 'api/user/login', data: &#123; username: $login.find('[name="username"]').val(), password: $login.find('[name="password"]').val(), &#125;, dataType: 'json', success: function (result) &#123; $login.find('.user_err').html(result.message) // 登录成功 if (!result.code) &#123; window.location.reload() &#125; &#125; &#125;) &#125;) 后台路由处理及数据库查询 1234567891011121314151617181920212223242526272829303132333435// 登录逻辑处理router.post('/user/login', (req, res) =&gt; &#123; var username = req.body.username var password = req.body.password if (username == '' || password == '') &#123; responseData.code = 1 responseData.message = '去填完再点登录' res.json(responseData) return &#125;// 查询数据库用户名密码同时存在 User.findOne(&#123; username: username, password: password &#125;).then((userInfo) =&gt; &#123; if (!userInfo) &#123; responseData.code = 2 responseData.message = '用户名或密码错啦' res.json(responseData) return &#125; // 正确 登录成功 responseData.message = '耶~ 登录成功' responseData.userInfo = &#123; _id: userInfo._id, username: userInfo.username &#125; req.cookies.set('userInfo', JSON.stringify(&#123; _id: userInfo._id, username: escape(userInfo.username) &#125;)) res.json(responseData) &#125;)&#125;) 3.5 cookies 上面的案例中，为了记录我们的登录状态，我们使用了第三发包 – cookies 来存储登录信息 app 引入 cookies模块 1var Cookies = require('cookies') 在 api.js 中获取 cookies 1234req.cookies.set('userInfo', JSON.stringify(&#123; _id: userInfo._id, username: escape(userInfo.username) &#125;)) ​ 在 app.js 中解析登录用户的cookies 12345678910111213141516171819202122// 设置cookiesapp.use((req, res, next) =&gt; &#123; req.cookies = new Cookies(req, res) // 解析登录用户的cookies req.userInfo = &#123;&#125; if (req.cookies.get('userInfo')) &#123; try &#123; req.userInfo = JSON.parse(req.cookies.get('userInfo')) // 获取用户是否是管理员 User.findById(req.userInfo._id).then((userInfo) =&gt; &#123; req.userInfo.isAdmin = Boolean(userInfo.isAdmin) next() &#125;) &#125; catch (e) &#123; next() &#125; &#125; else &#123; next() &#125;&#125; 用 swig 渲染模板控制 index页面 3.6登出ajax –》 api.js –&gt; cookies设置为空 -&gt; 刷新页面 登出的实现就比较简单，只需将cookies设置为空即可 前台ajax 1234567891011// 登出$('#logout').on('click', function () &#123; $.ajax(&#123; url: '/api/user/logout', success: function(result) &#123; if (!result.code) &#123; window.location.reload() &#125; &#125; &#125;)&#125;) api路由 12345// 退出登录router.get('/user/logout', (req, res) =&gt; &#123; req.cookies.set('userInfo', null) res.json(responseData)&#125;) 3.7 中文用户名登录异常原因 cookies在存储中午时出现乱码解决办法 将username进行转码再解码 使用 encode 和 decode 来进 编码和解码 3.8 区分管理员给userInfo 添加 isAdmin 属性 使用swig 选择渲染 四、后台管理4.1 bootstrap 模板建立页面4.2 使用继承模板公用的继承 1&#123;% extends 'layout.html' %&#125; 特殊的重写 123456&#123;% block main %&#125; &lt;div class="jumbotron"&gt; &lt;h1&gt;Hello, &#123;&#123;userInfo.username&#125;&#125;!&lt;/h1&gt; &lt;p&gt;欢迎进入后台管理&lt;/p&gt; &lt;/div&gt;&#123;% endblock%&#125; admin 首页 123456// 首页router.get('/', (req, res, next) =&gt; &#123; res.render('admin/index', &#123; userInfo: req.userInfo &#125;)&#125;) 4.3 admin/user 用户管理 建立静态 user_index.html 处理路由及分页逻辑 1234567891011121314151617181920212223242526272829303132333435363738394041// 用户管理router.get('/user', (req, res) =&gt; &#123; /* 从数据库中读取所有的用户数据 limit(number) 限制获取的数据条数 skip(number) 忽略数据的条数 每页显示 5 条 第一页： 1-5 skip：0 -&gt; (当前页 1 - 1) * 每页的条数 第二页： 6-10 skip：5 -&gt; (当前页 2 - 1) * 每页的条数 ... ... User.count() 查询总数据量 */ var page = Number(req.query.page || 1) var pages = 0 var limit = 10 User.count().then((count) =&gt; &#123; // 计算总页数 pages = Math.ceil(count / limit) // 取值不能超过 pages page = Math.min(page, pages) // 取值不能小于1 page = Math.max(page, 1) var skip = (page - 1) * limit // 读取数据库中所有用户数据 User.find().limit(limit).skip(skip).then((users) =&gt; &#123; res.render('admin/user_index', &#123; userInfo: req.userInfo, users: users, page: page, pages: pages, count: count, limit: limit &#125;) &#125;) &#125;) &#125;) 页面展示 –table表格 分页 数据里 limit skip() 分页原理 12345678910111213141516171819/*从数据库中读取所有的用户数据 limit(number) 限制获取的数据条数 skip(number) 忽略数据的条数 每页显示 5 条 第一页： 1-5 skip：0 -&gt; (当前页 1 - 1) * 每页的条数 第二页： 6-10 skip：5 -&gt; (当前页 2 - 1) * 每页的条数 ... ... */var page = req.query.page || 1var limit = 5var skip = (page - 1) * limitUser.find().limit(limit).skip(skip).then((users) =&gt; &#123; res.render('admin/user_index', &#123; userInfo: req.userInfo, users: users &#125;)&#125;) 客户端实现 123456789&lt;nav aria-label="..."&gt; &lt;ul class="pager"&gt; &lt;li class="previous"&gt;&lt;a href="/admin/user?page=&#123;&#123;page-1&#125;&#125;"&gt;&lt;span aria-hidden="true"&gt;&amp;larr;&lt;/span&gt;上一页&lt;/a&gt;&lt;/li&gt; &lt;li&gt; 一共有 &#123;&#123;count&#125;&#125; 条数据 || 每页显示 &#123;&#123;limit&#125;&#125; 条数据 || 一共 &#123;&#123;pages&#125;&#125; 页 || 当前第 &#123;&#123;page&#125;&#125; 页 &lt;/li&gt; &lt;li class="next"&gt;&lt;a href="/admin/user?page=&#123;&#123;page+1&#125;&#125;"&gt;下一页&lt;span aria-hidden="true"&gt;&amp;rarr;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 服务端代码 123456789101112131415161718192021222324252627282930313233343536/* 从数据库中读取所有的用户数据 limit(number) 限制获取的数据条数 skip(number) 忽略数据的条数 每页显示 5 条 第一页： 1-5 skip：0 -&gt; (当前页 1 - 1) * 每页的条数 第二页： 6-10 skip：5 -&gt; (当前页 2 - 1) * 每页的条数 ... ... User.count() 查询总数据量 */ var page = Number(req.query.page || 1) var pages = 0 var limit = 5 User.count().then((count) =&gt; &#123; // 计算总页数 pages = Math.ceil(count / limit) // 取值不能超过 pages page = Math.min(page, pages) // 取值不能小于1 page = Math.max(page, 1) var skip = (page - 1) * limit User.find().limit(limit).skip(skip).then((users) =&gt; &#123; res.render('admin/user_index', &#123; userInfo: req.userInfo, users: users, page: page, pages: pages, count: count, limit: limit &#125;) &#125;) &#125;) 抽取page 使用 include 语法以后复用 4.4 文章分类相关 分类首页 category_index.html 添加分类 category_add.html get 渲染页面 post 提交页面 设计表结构schemas/categories.jsmodels/categories.js 相关代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*添加分类页面 */router.get('/category/add', (req, res) =&gt; &#123; res.render('admin/category_add', &#123; userInfo: req.userInfo &#125;)&#125;)/*添加分类的保存 */router.post('/category/add', (req, res) =&gt; &#123; var name = req.body.name || '' if (name == '') &#123; res.render('admin/error', &#123; userInfo: req.userInfo, message: '名称不能为空' &#125;) return &#125; // 是否已有分类 Category.findOne(&#123; name: name &#125;).then((result) =&gt; &#123; if (result) &#123; // 数据库中已经存在 res.render('admin/error', &#123; userInfo: req.userInfo, message: '分类已经存在' &#125;) return Promise.reject() &#125; else &#123; // 数据库中不存在分类 return new Category(&#123; name: name &#125;).save() &#125; &#125;).then((newCategory) =&gt; &#123; res.render('admin/success', &#123; userInfo: req.userInfo, message: '分类保存成功', url: '/admin/category' &#125;) &#125;)&#125;) 通过判断 渲染 error 或者 success 的页面 两个页面都在 admin/error.html 和 admin/success.html 中 首页展示展示 同用户管理首页展示一样 1234567891011121314151617181920212223242526272829/*分类首页 */router.get('/category', (req, res) =&gt; &#123; var page = Number(req.query.page || 1) var pages = 0 var limit = 10 Category.count().then((count) =&gt; &#123; // 计算总页数 pages = Math.ceil(count / limit) // 取值不能超过 pages page = Math.min(page, pages) // 取值不能小于1 page = Math.max(page, 1) var skip = (page - 1) * limit Category.find().limit(limit).skip(skip).then((categories) =&gt; &#123; res.render('admin/category_index', &#123; userInfo: req.userInfo, categories: categories, page: page, pages: pages, count: count, limit: limit &#125;) &#125;) &#125;)&#125;) 分类修改 删除 在渲染的分类首页的分类表格中加入 1234&lt;td&gt; &lt;a href="/admin/category/edit?id=&#123;&#123;category._id.toString()&#125;&#125;" class="btn btn btn-primary"&gt;修改&lt;/a&gt; &lt;a href="/admin/category/delete?id=&#123;&#123;category._id.toString()&#125;&#125;" class="btn btn-danger"&gt;删除&lt;/a&gt;&lt;/td&gt; 通过query的传值分类的id 值 我们来操作id 修改 get 1234567891011121314151617181920212223/* 分类修改 get */router.get('/category/edit', (req, res) =&gt; &#123; // 获取要修改的分类信息 表单形式展现出来 var id = req.query.id || '' // 获取修改的分类信息 Category.findById(id).then((category) =&gt; &#123; if (!category) &#123; res.render('admin/error', &#123; userInfo: req.userInfo, message: '分类信息不存在' &#125;) return Promise.reject() &#125; else &#123; res.render('admin/category_edit', &#123; userInfo: req.userInfo, category: category &#125;) &#125; &#125;)&#125;) post 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* 分类修改 post */router.post('/category/edit', (req, res) =&gt; &#123; var id = req.query.id || '' var name = req.body.name || '' Category.findById(id).then((category) =&gt; &#123; if (!category) &#123; res.render('admin/error', &#123; userInfo: req.userInfo, message: '分类信息不存在' &#125;) return Promise.reject() &#125; else &#123; // 当前用户没有做任何修改而提交 if (name == category.name) &#123; res.render('admin/success', &#123; userInfo: req.userInfo, message: '修改成功', url: '/admin/category' &#125;) return Promise.reject() &#125; else &#123; // 要修改的分类名称是否已经在数据库中 return Category.findOne(&#123; // id 不等于当前的id _id: &#123;$ne: id&#125;, name: name &#125;) &#125; &#125; &#125;).then((sameCategory) =&gt; &#123; if (sameCategory) &#123; res.render('admin/error', &#123; userInfo: req.userInfo, message: '已存在同名分类' &#125;) return Promise.reject() &#125; else &#123; return Category.findByIdAndUpdate(id, &#123; name: name &#125;) &#125; &#125;).then(() =&gt; &#123; res.render('admin/success', &#123; userInfo: req.userInfo, message: '修改分类名称成功', url: '/admin/category' &#125;) &#125;)&#125;) 删除 1234567891011121314151617/* 分类删除 */router.get('/category/delete', (req, res) =&gt; &#123; // 获取id var id = req.query.id || '' Category.remove(&#123; _id: id &#125;).then(() =&gt; &#123; res.render('admin/success', &#123; userInfo: req.userInfo, message: '删除成功', url: '/admin/category' &#125;) &#125;)&#125;) ​ 4.5 内容管理 -内容首页和内容添加12345678910111213141516171819202122/* 内容首页 */router.get('/content', (req, res) =&gt; &#123; res.render('admin/content_index', &#123; userInfo: req.userInfo &#125;)&#125;)/* 内容添加 */router.get('/content/add', (req, res) =&gt; &#123; Category.find().sort(&#123;_id: -1&#125;).then((categories) =&gt; &#123; console.log(categories) res.render('admin/content_add', &#123; userInfo: req.userInfo, categories: categories &#125;) &#125;)&#125;) 4.6内容提交保存 新建 schemas/content.js 和 models/content.js 建立content模型 处理路由 post 后台 1234567891011121314 // 保存内容到数据库 new Content(&#123; category: req.body.category, title: req.body.title, description: req.body.description, content: req.body.content &#125;).save().then((content) =&gt; &#123; res.render('admin/success', &#123; userInfo: req.userInfo, message: '内容保存成功', url: '/admin/content' &#125;) &#125;)&#125;) 4.7 关于内容分类的表关联关系123456789101112131415161718192021module.exports = new mongoose.Schema(&#123; title: &#123; type: String &#125;, // 引用 关联字段 category: &#123; type: mongoose.Schema.Types.ObjectId, //引用 另外一张表的模型 ref: 'Category' &#125;, description: &#123; type: String, default: '' &#125;, content: &#123; type: String, default: '' &#125;&#125;) 我们在 处理 content 的 category的时候 关联个 另外一个结构表 在渲染页面的时候用mongoose 中提供搞得 populate() 方法 知识点6： mongoose中的表关联 Population 可以自动替换 document 中的指定字段，替换内容从其他 collection 获取。 我们可以填充（populate）单个或多个 document、单个或多个纯对象，甚至是 query 返回的一切对象 简单的说，A表的可以关联B表，通过调用A表的属性数据取到B表内容的值，就像sql的join的聚合操作一样。 123456789101112131415161718var mongoose = require('mongoose');var Schema = mongoose.Schema;var personSchema = Schema(&#123; _id: Schema.Types.ObjectId, name: String, age: Number, stories: [&#123; type: Schema.Types.ObjectId, ref: 'Story' &#125;]&#125;);var storySchema = Schema(&#123; author: &#123; type: Schema.Types.ObjectId, ref: 'Person' &#125;, title: String, fans: [&#123; type: Schema.Types.ObjectId, ref: 'Person' &#125;]&#125;);var Story = mongoose.model('Story', storySchema);var Person = mongoose.model('Person', personSchema); 我们创建了Story 和 Person两个数据库实例。 Person model 的 stories 字段设为 ObjectId数组。 ref 选项告诉 Mongoose 在填充的时候使用哪个 model，本例中为 Story model。 接下来我们使用 Population 来填充使用 12345678Story. findOne(&#123; title: 'Casino Royale' &#125;). populate('author'). exec(function (err, story) &#123; if (err) return handleError(err); console.log('The author is %s', story.author.name); // prints "The author is Ian Fleming" &#125;); 更多高级用法： Mongoose Populate 4.8 内容修改12345678910111213141516171819202122232425262728293031/* 修改内容 */router.get('/content/edit', (req, res) =&gt; &#123; // 获取要修改的内容信息 表单形式展现出来 var id = req.query.id || '' var categories = [] // 获取分类信息 Category.find().sort(&#123; _id: -1 &#125;) .then((result) =&gt; &#123; categories = result return Content.findById(id).populate('category') &#125;) .then((content) =&gt; &#123; console.log(content) if (!content) &#123; res.render('admin/error', &#123; userInfo: req.userInfo, message: '指定内容不存在' &#125;) return Promise.reject() &#125; else &#123; res.render('admin/content_edit', &#123; userInfo: req.userInfo, content: content, categories: categories &#125;) &#125; &#125;) 4.9 内容保存1234567891011121314151617181920212223242526272829303132333435363738/* 内容修改 */ router.post('/content/edit', function(req, res) &#123; var id = req.query.id || '' if (req.body.title == '') &#123; res.render('admin/error', &#123; userInfo: req.userInfo, message: '标题不能为空' &#125;) return &#125; if (req.body.description == '' || req.body.content == '') &#123; res.render('admin/error', &#123; userInfo: req.userInfo, message: '简介和内容不能为空' &#125;) return &#125; Content.findByIdAndUpdate(id, &#123; category: req.body.category, title: req.body.title, description: req.body.description, content: req.body.content &#125;).then(() =&gt; &#123; res.render('admin/success', &#123; userInfo: req.userInfo, message: '内容保存成功', url: '/admin/content' &#125;) &#125;) &#125;) &#125;) 4. 10内容删除1234567891011121314151617/* 内容删除*/router.get('/content/delete', (req, res) =&gt; &#123; // 获取id var id = req.query.id || '' Content.remove(&#123; _id: id &#125;).then(() =&gt; &#123; res.render('admin/success', &#123; userInfo: req.userInfo, message: '删除成功', url: '/admin/content' &#125;) &#125;)&#125;) 添加一些文章 信息 – 作者 创建时间 点击量作者 – 关联 user表 创建时间 – new Date() ​ 前台渲染 1&lt;td&gt;&#123;&#123;content.addTime|date('Y-m-d H:i:s', -8*60)&#125;&#125;&lt;/td&gt; 点击量 –》 先默认为 0 五、前台相关 有了后台的数据，我们接下来看前台的 修改 main.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*首页渲染 */router.get('/', function (req, res, next) &#123; req.userInfo.username = unescape(req.userInfo.username) var data = &#123; userInfo: req.userInfo, categories: [], contents: [], count: 0, page : Number(req.query.page || 1), pages : 0, limit : 10 &#125; Category.find() .then((categories) =&gt; &#123; data.categories = categories return Content.count() &#125;) .then((count) =&gt; &#123; data.count = count // 计算总页数 data.pages = Math.ceil(data.count / data.limit) // 取值不能超过 pages data.page = Math.min(data.page, data.pages) // 取值不能小于1 data.page = Math.max(data.page, 1) var skip = (data.page - 1) * data.limit return Content .find() .sort(&#123; addTime: -1 &#125;) .limit(data.limit) .skip(skip) .populate(['category', 'user']) &#125;) .then((contents) =&gt; &#123; data.contents = contents console.log(data) res.render('main/index', data) &#125;)&#125;) 5.1 完善首页细节 改为后台传来的data显示使用swig的渲染模板 完善页面信息，不在赘述 5.2 设置分页12345678910111213141516&#123;% if pages &gt; 1 %&#125;&lt;nav aria-label="..." id="pager_dh"&gt; &lt;ul class="pager"&gt; &#123;% if page &lt;=1 %&#125; &lt;li class="previous"&gt;&lt;span href="#"&gt;&lt;span aria-hidden="true"&gt;&amp;larr;&lt;/span&gt;没有上一页了&lt;/span&gt;&lt;/li&gt; &#123;%else%&#125; &lt;li class="previous"&gt;&lt;a href="/?category=&#123;&#123;category&#125;&#125;&amp;page=&#123;&#123;page-1&#125;&#125;"&gt;&lt;span aria-hidden="true"&gt;&amp;larr;&lt;/span&gt;上一页&lt;/a&gt;&lt;/li&gt; &#123;%endif%&#125; &lt;span class="page_text"&gt;&#123;&#123;page&#125;&#125; / &#123;&#123;pages&#125;&#125;&lt;/span&gt; &#123;% if page &gt;=pages %&#125; &lt;li class="next"&gt;&lt;span href="#"&gt;没有下一页了&lt;span aria-hidden="true"&gt;&amp;rarr;&lt;/span&gt;&lt;/li&gt; &#123;%else%&#125; &lt;li class="next"&gt;&lt;a href="/?category=&#123;&#123;category&#125;&#125;&amp;page=&#123;&#123;page+1&#125;&#125;"&gt;下一页&lt;span aria-hidden="true"&gt;&amp;rarr;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &#123;%endif%&#125; &lt;/ul&gt;&lt;/nav&gt;&#123;%endif%&#125; ####5.3 content 创建时间的问题 我们创建addTime的时候，会发现mongod创建的数据的时间戳完全一样 我们不能使用new date()来创建默认时间 使用 Date.now 5.4 处理分类点击跳转1234var where = &#123;&#125;if (data.category) &#123; where.category = data.category&#125; mongoose查询的时候使用 where 查询 5.5 分类高亮显示123456789101112131415&lt;nav class="head_nav"&gt; &#123;% if category == ''%&#125; &lt;a href="/" id="inactive"&gt;首页&lt;/a&gt; &#123;%else%&#125; &lt;a href="/"&gt;首页&lt;/a&gt; &#123;%endif%&#125; &#123;% for cate in categories%&#125; &#123;% if category == cate.id%&#125; &lt;a href="/?category=&#123;&#123;cate.id&#125;&#125;" id="inactive"&gt;&#123;&#123;cate.name&#125;&#125;&lt;/a&gt; &#123;%else%&#125; &lt;a href="/?category=&#123;&#123;cate.id&#125;&#125;"&gt;&#123;&#123;cate.name&#125;&#125;&lt;/a&gt; &#123;%endif%&#125; &#123;% endfor %&#125;&lt;/nav&gt; 5.6 评论相关评论使用ajax来操作 使用ajax操作不刷新页面来操作api 后台api代码 1234567891011121314151617181920212223242526272829303132333435/*进入详情获取评论 */router.get('/comment/post', (req, res) =&gt; &#123; var contentid = req.query.contentid Content.findById(contentid) .then((content) =&gt; &#123; responseData.data = content.comments res.json(responseData) &#125;)&#125;)/*评论提交 */router.post('/comment/post', (req, res) =&gt; &#123; var contentid = req.body.contentid var postData = &#123; username: req.userInfo.username, postTime: Date.now(), content: req.body.content &#125; // 查询文章内容信息 Content.findById(contentid) .then((content) =&gt; &#123; content.comments.push(postData) return content.save() &#125;) .then((newContent) =&gt; &#123; responseData.message = '评论成功!' responseData.data = newContent res.json(responseData) &#125;)&#125;) 评论代码 ajax的操作都封装在了 routers/api.js 中 评论相关操作我们都放在了js/comments.js 中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100var limit = 4var page = 1var pages = 0var comments = []// 加载所有评论$.ajax(&#123; type: 'get', url: 'api/comment/post', data: &#123; contentid: $('#contentId').val(), &#125;, success: ((responseData) =&gt; &#123; comments = responseData.data renderComment() &#125;)&#125;)$('.pager').delegate('a', 'click', function() &#123; if ($(this).parent().hasClass('previous')) &#123; page-- &#125; else &#123; page++ &#125; renderComment()&#125;)// 提交评论$('#commentBtn').on('click',function() &#123; $.ajax(&#123; type: 'post', url: 'api/comment/post', data: &#123; contentid: $('#contentId').val(), content: $('#commentContent').val() &#125;, success: ((responseData) =&gt; &#123; $('#commentContent').val('') comments = responseData.data.comments renderComment(true) &#125;) &#125;)&#125;)function renderComment (toLaster) &#123; $('#discuss_count').html(comments.length) var $lis = $('.pager li') pages = Math.ceil(comments.length / limit) if (!toLaster) &#123; var start = (page-1) * limit &#125; else &#123; var start = (pages - 1) * limit page = pages &#125; var end = (start + limit) &gt; comments.length ? comments.length : (start + limit) if (pages &lt;= 1) &#123; $('.pager').hide() &#125; else &#123; $('.pager').show() $lis.eq(1).html(page + '/' + pages ) if (page &lt;= 1) &#123; page = 1 $lis.eq(0).html('&lt;span&gt;已是最前一页&lt;/span&gt;') &#125; else &#123; $lis.eq(0).html('&lt;a href="javacript:void(0);"&gt;上一页&lt;/a&gt;') &#125; if (page &gt;= pages) &#123; page = pages $lis.eq(2).html('&lt;span&gt;已是最后一页&lt;/span&gt;') &#125; else &#123; $lis.eq(2).html('&lt;a href="javacript:void(0);"&gt;下一页&lt;/a&gt;') &#125; &#125; var html = '' if (comments.length) &#123; for (var i = start; i &lt; end; i++) &#123; html += ` &lt;li&gt; &lt;p class="discuss_user"&gt;&lt;span&gt;$&#123;comments[i].username&#125;&lt;/span&gt;&lt;i&gt;发表于 $&#123;formatDate(comments[i].postTime)&#125;&lt;/i&gt;&lt;/p&gt; &lt;div class="discuss_userMain"&gt; $&#123;comments[i].content&#125; &lt;/div&gt; &lt;/li&gt; ` &#125; &#125; $('.discuss_list').html(html)&#125;function formatDate(d) &#123; var date1 = new Date(d) return date1.getFullYear() + '年' + (date1.getMonth()+1) + '月' + date1.getDate() + '日' + date1.getHours() + ':' + date1.getMinutes() + ':' + date1.getSeconds()&#125; 六、总结项目这个阶段知识简单能跑痛而已，包括细节的优化，和程序的安全性都没有考虑，安全防范措施为零，这也是以后要学习的地方。 第一次使用node写后台，完成了一次前后端的完整交互，最终要的还是做后台的一种思想，一种处理前后台关系的逻辑。 收获了很多，越来越感觉自己要学的东西太多了，自己好菜。。 写总结文档有点累唉 (°:з」∠)秃头。]]></content>
      <categories>
        <category>Node</category>
        <category>Project</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
        <tag>project</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node中的mongodb和mongoose]]></title>
    <url>%2F2018%2F10%2F06%2Fnode%E4%B8%AD%E7%9A%84mongodb%E5%92%8Cmongoose%2F</url>
    <content type="text"><![CDATA[在node中的 Mongodb 以及 第三方封装的 mongoose 简单使用。 mongodb MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 1. 安装相关1.1 下载 官网下载地址 ：官网下载社区版 1.2 安装及环境配置 安装 下载的是 zip 解压到想要的路径即可 配置 我的电脑 –&gt; 属性 –&gt; 高级系统设置 –&gt; 环境变量 –&gt; 编辑用户变量的 path –&gt; 添加解压mongondb路径下的bin目录即可 1.3 检测 在cmd控制台输入 mongod --version 出现版本信息及安装成功 2. 使用相关2.1 开启和关闭数据库 启动 123# mongodb 默认使用执行 mongod 命令，会调用当前目录盘符根目录下的 /data/db 文件夹作为数据存储目录# 所以如果第一次在新的盘符下执行mongod前应手动创建一个 /data/db 目录mongod 在执行路径根目录下没有 data/db 目录会导致报错 启动失败 如果想自定义数据存储目录，可以 1mongod --dbpath=你想要的存储的路径 停止 Ctrl + C 或者直接关闭控制台即可 2.2 连接、退出数据库 连接 在开启的前提下，再开一个cmd控制台窗口 执行： 12# 该命令默认连接本机的 MongoDB服务mongo 注意：连接数据库也要保证目录下的data/db 目录存在，否则的话可能会导致连不上 退出 退出数据库不是关闭数据库 12# 在连接的状态窗口下输入 exit 接口退出exit 2.3 基本命令 show dbs 查看显示所有数据库 1234&gt; show dbsadmin 0.000GBconfig 0.000GBlocal 0.000GB 上面三个数据库是系统数据库，我们最好不要操作他们 db 查看当前操作的数据库 use 数据库名称切换到指定的数据库，如果没有，则新建 。。。 开发过程中一般不使用黑窗口cmd来操作数据库 3. 在node中使用MongoDB3.1 使用官方的 mongodb 包来操作 官方mongodb包 里面提供了很多数据库操作的API， 但是对于开发来说，还是相比较为底层，所以开发中也不常用 3.2 使用第三方 mongoose 操作数据库第三方包，基于MongoDB官方的 mongodb 包又进行了一次封装。 官网 官网指南 官网API 安装 1npm install mongoose hello world 1234567const mongoose = require('mongoose');mongoose.connect('mongodb://localhost/test');const Cat = mongoose.model('Cat', &#123; name: String &#125;);const kitty = new Cat(&#123; name: 'Zildjian' &#125;);kitty.save().then(() =&gt; console.log('meow')); 4. mongoose初次使用小demo4.1 起步 初始化12345678910111213141516171819202122232425262728293031323334var mongoose = require('mongoose')// 数据库中的Schema，为数据库对象的集合var Schema = mongoose.Schema// 连接数据库// 指定连接的数据库不需要存在，当你插入第一条数据的之后会自动创建出来mongoose.connect('mongodb://localhost/mytest')// 设计集合结构// 约束数据的类型及其他的一些要求 避免脏数据var userSchema = new Schema(&#123; username: &#123; type: String, required: true // 必须有 不能为空 &#125;, password: &#123; type: String, required: true &#125;, email: &#123; type: String &#125;&#125;)// 将文档结构发布为模型// mongoose.model 方法就是将一个架构发布为 model// 第一个参数： 传入一个首字母大写名词单数字符串，表示数据库名称// mongoose 会自动将大写名词的字符串生成 小写复数 的集合名称// 例如:这里的User 最终会编程 users 集合名称// 第二个参数： 架构 Schema// 返回值： 模型构造函数// 有了这个模型构造函数之后，就可以对 这个集合中的数据 进行我们想要的操作了var User = mongoose.model('User', userSchema) 4.2 添加数据save() 12345678910111213141516...var admin = new User(&#123; username: 'admin', password: '123456', email: 'admin@qq.com'&#125;)admin.save(function (err, ret) &#123; if (err) &#123; console.log('保存失败') &#125; else &#123; console.log('保存成功') console.log(ret) &#125;&#125;) 这里的输出： 123456保存成功&#123; _id: 5bb87029fb8d521954db7d25, username: 'admin', password: '123456', email: 'admin@qq.com', __v: 0 &#125; 4.3 查询数据 查询所有 1234567User.find(function(err, ret) &#123; if (err) &#123; console.log('error') &#125; else &#123; console.log(ret) &#125;&#125;) 按条件查询 12345678910User.find(&#123; // 筛选条件 username: 'zs' // 筛选出username 为 zs 的数据&#125;,function (err, ret) &#123; if (err) &#123; console.log('error') &#125; else &#123; console.log(ret) &#125;&#125;) 查询一个 findOne 123456789User.findOne(&#123; username: 'zs' // 筛选出username 为 zs 的数据&#125;, function (err, ret) &#123; if (err) &#123; console.log('error') &#125; else &#123; console.log(ret) &#125;&#125;) 这里查找一个 返回的不再是一个数组，而是一个对象 找不到即返回 null 不加筛选条件就返回第一条数据 4.4 删除数据1234567User.remove(&#123; username: 'admin'&#125;, function (err) &#123; if (err) &#123; console.log('error') &#125;&#125;) 4.5 更新数据123456789User.findByIdAndUpdate('5bb87a44b70a9508346d35f9', &#123; password: '123'&#125;, function (err) &#123; if (err) &#123; console.log('更新失败') &#125; else &#123; console.log('更新成供') &#125;&#125;) 以上的操作只是写简单的基本操作，更加复杂的操作情景可一查看官网api。]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express初级使用笔记]]></title>
    <url>%2F2018%2F10%2F01%2Fexpress%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[学习了解node最流行框架之一 – express Express express 是 node 中最流行的框架之一。 1. 起步安装： 1npm install express --save hello world 1234567891011121314151617181920212223const express = require('express')// 创建服务器const app = express()// 当服务区 收到get 请求 '/' 时， 指向回调处理函数app.get('/', function (req, res) &#123; res.send('hello world')&#125;)app.get('/about', function (req, res) &#123; console.log(req.query) res.send('hello about me~')&#125;)// 在 express 中 开放资源 就是一个 api 的事app.use('/static/', express.static('./static/'))// http://localhost:3000/static/loading.gif 即可访问图片// 建立监听端口 相当于 server.listenapp.listen(3000, function () &#123; console.log('app is running at http://localhost:3000')&#125;) 2. 基本路由get： 123app.get('/', function (req, res) &#123; res.send('hello world')&#125;) post: 123app.post(&apos;/&apos;, function (req, res) &#123; res.send(&apos;get a post request&apos;)&#125;) 3. 静态服务12345678// 直接就能访问public目录下的资源app.use(express.static('public'))// public/xxxapp.use('/public/', express.static('./public/'))// static/xxxapp.use('/static/', express.static('./static/')) 4. 在express中使用 art-template模板引擎安装 12npm install --save art-templatenpm install --save express-art-template 配置： 1app.engine('html', require('express-art-template')) // 最核心的代码 配置使用 art-template渲染模板引擎 第一个参数表示，当渲染以 .html结尾的文件时 使用渲染模板，可以更改为其他的后缀 使用： 12345app.get('/', function (req, res) &#123; res.render('index.html', &#123; title: '.....' // 渲染属性 &#125;)&#125;) express 为 response 响应对象提供了一个 render 方法 这个render方法默认不可以使用，只有像上面配置了模板引擎后才可以使用这个方法 res.render(‘html模板名’, {模板数据}) 上面的第一个参数不能写路径，express默认去 项目的 views 目录中寻找该模板文件 也就是说 express 有一个约定，开发人员最好把视图文件都放在 views 文件目录中 如果想要修改默认的 views 目录， 可以 app.set(‘views’, render函数的默认路径)来更改 5. 在express中获取 表单 get 请求体数据1req.query express 内置了一个 API， 可以直接 通过 req.query 来获取 6. 在express中获取 表单 post 请求体数据 Express middleware 中间件 给我们提供了很多常用的插件，其中就有处理 post 请求体的插件body-parser 安装： 1npm install body-parser 配置： 1234567891011121314151617var express = require('express')var bodyParser = require('body-parser')var app = express()// 配置 bodyParser 只要加入这个配置，则在 req 请求对象上 会多出一个属性body// 也就是说你可以直接通过 req.body 来获取表单 post 请求体数据了app.use(bodyParser.urlencoded(&#123; extended: false &#125;))// parse application/jsonapp.use(bodyParser.json())app.use(function (req, res) &#123; res.setHeader('Content-Type', 'text/plain') res.write('you posted:\n') // 通过 req.body 获取数据 res.end(JSON.stringify(req.body, null, 2))&#125;) 7. 修改完代码自动重启服务 我们可以使用一个第三方工具 nodemon 来帮助我们解决频繁修改服务端代码重启服务器的问题 nodemon是一个基于node.js开发的第三方命令，我们一般使用时可全局安装 1npm install nodemon --global 安装完毕后，使用命令 1nodemon app.js（要执行的文件） 通过 nodemon启动后的服务，会被实时监控，只要文件发生改变，就会自动帮你重启服务器。 8. 用express 来重写上次的 原生node留言版1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var express = require('express')var app = express()// 配置使用 art-template渲染模板引擎// 第一个参数表示，当渲染以 .html 结尾的文件时 使用渲染模板，可以更改app.engine('html', require('express-art-template'))app.use('/public/', express.static('public'))var comments = [ &#123; name: '阿孔', message: 'Yo~~', dataTime: '2018-09-27' &#125;, &#123; name: '老许', message: 'Yo~@@@~', dataTime: '2018-09-27' &#125;]// express 为 response 响应对象提供了一个 render 方法// 这个render方法默认不可以使用，只有像上面配置了模板引擎后才可以使用这个方法// res.render('html模板名', &#123;模板数据&#125;)// 上面的第一个参数不能写路径，express默认去 项目的 views 目录中寻找该模板文件// 也就是说 express 有一个约定，开发人员最好把视图文件都放在 views 文件目录中// 如果想要修改默认的 views 目录， 可以 app.set('views', render函数的默认路径)来更改app.get('/', function (req, res) &#123; res.render('index.html', &#123; comments &#125;)&#125;)app.get('/post', function (req, res) &#123; res.render('post.html')&#125;)app.get('/pinglun', function (req, res) &#123; var comment = req.query // req.query 只能拿get请求参数 comment.dataTime = '2018-10-01' comments.unshift(comment) res.redirect('/') // res.statusCode = 302 // res.setHeader('Location', '/') // express 封装的 res.send 和 res.redirect 等方法都会自动结束响应&#125;)app.listen(3000, function () &#123; console.log('http://localhost:3000')&#125;) express 封装了很多方法，res.render, res.redirect, req.query 等，打打减少了代码量。 这里知识简单的尝试一下express，继续学习。]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[moudle.exports,exprots原理 & require路径解析]]></title>
    <url>%2F2018%2F09%2F29%2Fmoudle-exports-exprots%E5%8E%9F%E7%90%86-require%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[node中的module.exports与exports的联系与区别以及模块查找工作机制（require） Module.exports 和 exports 在node中，没有全局作用域，只有模块作用域，外部访问不到内部，内部也访问不到外部,那么模块间如何通信 当加载一个模块的时候，被加载模块的代码在第一次加载的时候会执行一遍 module.exports 被加载模块可以使用 node 提供 的 module.exports 来绝对向外暴露的内容（不设置的话默认为一个空对象） module 在node.js 模块中一般都表示本模块的意思 require 函数真是实现： 12345678910111213function require(/* ... */) &#123; const module = &#123; exports: &#123;&#125; &#125;; // exports 默认为空对象 ((module, exports) =&gt; &#123; // 模块代码在这。在这个例子中，定义了一个函数。 function someFunc() &#123;&#125; exports = someFunc; // 此时，exports 不再是一个 module.exports 的快捷方式， // 且这个模块依然导出一个空的默认对象。 module.exports = someFunc; // 此时，该模块导出 someFunc，而不是默认对象。 &#125;)(module, module.exports); return module.exports;&#125; #### exprot export 和 module.exports 指向的是同一个对象地址 最终 require() 函数返回的是 module.exports 中的数据 以当 module.exports 属性被一个新的对象完全替代时 , require 的数据肯定也会变成新值；但是，如果给 export 对象改变地址的话， module.exports不会改变， requrie的值自然也就不会发生变化；可以将 export 想象成 module.exports 的快捷方式 module.exports与exports的区别每一个node.js执行文件，都会创建一个module对象，同时，module对象会创建一个叫 exports 的属性，初始化的值是 { } module.exports = { } 在模块的结尾，会将 module.exports 返回 return module.exports 说白了，exprots 是 引用的 module.exprots的值，moudule.exprots 被改变的时候 ， exprots 不会被改变。 而模块导出的时候，真正导出的是 module.exprots， 而不是 exprots 实例解析同目录下创建两个文件, a.js, 和 b.js 在a.js写入代码, 输出foo来看看b.js导出的模块到底是什么 123var foo = require('./b')console.log(foo) b.js 什么也不写的情况下, { } 执行a.js 输出 一个空对象， 这也说明了我们的模块默认导出一个空对象 b.js 代码如下 1234exports.a = 1//此时 执行 a.js 输出 ：// &#123; a: 1 &#125; b.js 代码如下 123456module.exports.a = 2exports.a = 1//此时 执行 a.js 输出 ：// &#123; a: 1 &#125; 两句语句的操作其实是操作同一块对象地址，所以以最后的为准 a.js执行输出为1 b.js 代码如下 12345678module.exports = &#123; a : 2&#125;exports.a = 1//此时 执行 a.js 输出 ：// &#123; a: 2 &#125; 此时执行结果变为 2 为什么？ 因为第次赋值操作的时候，本质是改变了 moudule.exprots 的地址， 为 module.exports 开辟了一块新的地址来存储数据 ，而 exprots 还是 连接着 原来的共享地址。 而模块最后导出的是 module.exports 这样应该就能理解其中的原因了吧 来一个复杂的 1234567891011121314151617181920212223242526272829303132exports.a = 'aaa'// module.exports = &#123;// a: 'aaa'// &#125; module.exports.b = 123// module.exports = &#123;// a: 'aaa',// b: 123// &#125; exports = &#123; b: 456&#125;// 此时 exports 和 module.exprots 断开联系，不再是同一片地址module.exports.a = 'hahaha'// module.exports = &#123;// a: 'hahaha',// b: 123// &#125; exports.c = 456// 断开联系 赋值无法作用与 modul.exportsexports = module.exports// 又指向同一片地址exports.b = 789// module.exports = &#123;// a: 'hahaha',// b: 789// &#125; 最后输出 { a: &#39;hahaha&#39;, b: 789 } requirerequire一般导入下列三种包 内置核心模块 第三方模块 用户自己的模块 不可能有任何一个第三方包和核心模块的名字是一样的 模块查找机制 优先缓存 核心模块 路径形式的文件模块 第三方模块 当 Node 执行 require(A) 时，按下面处理 1. 当 A 是 内置模块 a, 返回该模块 b, 不在执行 2. 当 A 是 ‘./‘ ‘/‘ ‘../‘ 开头的路径请求 a, 确定 A 所在的父模块， 确定 A 的 绝对路径 b, 将 A 当成文件 依次查找 A A.js A.json A.node 只要其中有一个存在，就返回该文件，不再继续执行 c, 将 A 当成目录文件夹， 查找 A 文件夹下的下列文件 A/package.json A/index.js A/index.json A/index.node3. 当 A 属于第三方模块的时候 假想当前脚本文件 /home/akong/projects/foo.js 执行了 require(‘bar’) /home/akong/projects/node_modules/bar/home/akong/node_modules/bar/home/node_modules/bar/node_modules/bar node 会按照上面的顺序依次向上级的node_modules搜索bar 搜索时，node会先 bar 当成文件名 依次尝试加载下面这些文件，只要有一个成功就返回 1234barbar.jsbar.jsonbar.node 如果都不成功，就将bar当做文件夹，搜索下面的文件 1234bar/package.json（main字段）bar/index.jsbar/index.jsonbar/index.node 杂记 在node中，全局模块的使用不需要加载，而非全局模块则需要加载。 process 模块在使用的时候无需通过 require( )来加载该函数，可以直接使用，而 fs 模块不是全局模块，需要加载来使用 var fs = require(&#39;fs&#39;) Node 即是单线程的，又是异步非阻塞I/O data 参数的数据类型是一个 buffer 对象 ，里面保存的就是一个一个的字节（理解为字符数组）把buffer对象转化为字符串，用toString方法 默认 utf8 文件操作的 ./ 相对路径，相对的是执行 node 命令的路径 解决： __durbane：表示当前正在执行的 js 文件所在的目录 __filename: 表示当前正在执行的 js 文件的完整路径 两者都是本地变量，使用时不用加载 使用路径拼接的时候我们可以使用node提供的一个path模块，他可以更智能的识别反斜杠的存在和操作系统的兼容性，是我们的程序更简洁，兼容性更好 node 错误优先规则，在node回调中，一般都是用err当做第一个回调参数 try-catch 只能捕获 同步中的错误，异步中的错误无法用 trycatch来捕获，对于异步操作，要通过判断错误号（err.code）来进行出错处理 在请求服务器的时候，请求的url就只是一个标识，无其他作用 require 模块加载是同步的 当加载一个模块的时候，被加载模块的代码在第一次加载的时候会执行一遍，并缓存起来，后续加载的话就不会执行代码 node.js 遵循了 CommonJS 语法规范 在node中，没有全局作用域，只有模块作用域，外部访问不到内部，内部也访问不到外部]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>moudle.exprots</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生node实现简易留言板]]></title>
    <url>%2F2018%2F09%2F28%2F%E5%8E%9F%E7%94%9Fnode%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%95%99%E8%A8%80%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[学习node，实现一个简单的留言板小demo 原生node实现简易留言板 1. 使用模块 http模块 创建服务 fs模块 操作读取文件 url模块 便于path操作并读取表单提交数据 art-template模块（需npm安装） 服务端渲染 2. 服务端2.1 服务端代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667var http = require('http')var fs = require('fs')var url = require('url')var template = require('art-template')var comments = [ &#123; name:'阿孔', message: 'Yo~~', dataTime: '2018-09-27' &#125;, &#123; name: '老许', message: 'Yo~@@@~', dataTime: '2018-09-27' &#125;]http.createServer(function (req, res) &#123; var parseObj = url.parse(req.url, true) var pathname = parseObj.pathname if (pathname === '/') &#123; fs.readFile('./views/留言本.html', function (err, data) &#123; if (err) &#123; return res.end('404 Not Found') &#125; var htmlStr = template.render(data.toString(), &#123; comments: comments &#125;) res.end(htmlStr) &#125;) &#125; else if (pathname.indexOf('/public/') === 0) &#123; fs.readFile('.' + pathname, function (err, data) &#123; if (err) &#123; return res.end('404 Not Found') &#125; res.end(data) &#125;) &#125; else if (pathname === '/post') &#123; fs.readFile('./views/post.html', function (err, data) &#123; if (err) &#123; return res.end('404 Not Found') &#125; res.end(data) &#125;) &#125; else if (pathname === '/pinglun') &#123; // 追加到数组 var comment = parseObj.query comment.dataTime = '2018-10-01' comments.unshift(comment) // 跳转首页 // 如何通过服务器让客户端重定向 // 1. 状态码设置为 302 临时重定向 statusCode // 2. 在响应头中通过 location 告诉客户端去哪重定向 res.statusCode = 302 res.setHeader('Location', '/') res.end() &#125; else &#123; fs.readFile('./views/404.html', function(err, data) &#123; res.end(data) &#125;) &#125;&#125;).listen(3000, function () &#123; console.log('http://localhost:3000')&#125;) 2.2 页面渲染 使用了 第三方 的渲染模板工具 art-template,在请求 / 主页时，在服务端将页面中的数据渲染出来 数据来自comments数组 1234567891011if (pathname === '/') &#123; fs.readFile('./views/留言本.html', function (err, data) &#123; if (err) &#123; return res.end('404 Not Found') &#125; var htmlStr = template.render(data.toString(), &#123; comments: comments &#125;) res.end(htmlStr) &#125;)&#125; 2.3 评论提交 评论提交的实现，在post提交页面中 form表单的行为action指定 /pinglun，随后在服务端的app.js中处理 /pinglun路径请求逻辑 12345678910111213else if (pathname === '/pinglun') &#123; // 追加到数组 var comment = parseObj.query comment.dataTime = '2018-10-01' comments.unshift(comment) // 跳转首页 // 如何通过服务器让客户端重定向 // 1. 状态码设置为 302 临时重定向 statusCode // 2. 在响应头中通过 location 告诉客户端去哪重定向 res.statusCode = 302 res.setHeader('Location', '/') res.end() &#125; 其中，有几点需要注意 parseObj parseObj是通过url模块解析每次请求的路径得到的 var parseObj = url.parse(req.url, true) url中的parse方法可以将url解析为一段一段的数据 例如，我们在 node 中 执行下面代码 12345678910111213141516var parseObj = url.parse('http://localhost:3000/pinglun?name=aaa&amp;message=bbbbbbb', true)console.log(parseObj)Url &#123; protocol: 'http:', slashes: true, auth: null, host: 'localhost:3000', port: '3000', hostname: 'localhost', hash: null, search: '?name=aaa&amp;message=bbbbbbb', query: &#123; name: 'aaa', message: 'bbbbbbb' &#125;, pathname: '/pinglun', path: '/pinglun?name=aaa&amp;message=bbbbbbb', href: 'http://localhost:3000/pinglun?name=aaa&amp;message=bbbbbbb' &#125; 可以看到，url的方法直接将url解析成一个对象，里面包含着很多我们能方便使用的属性，入其中的query，这里面就包含着我们提交的数据信息，url.parse方法的第二个参数默认为 false ，若默认false的话，query就不是一个对象，而是一个字符串，设置为true后就会自动帮我们解析成一个对象，方便我们使用。 我们评论的追加就是取得这个parseObj.query对象中的数据 123var comment = parseObj.querycomment.dataTime = '2018-10-01'comments.unshift(comment) 最后在使用unshift数组方法追加到最前面，这样我们的评论功能就能实现了。 2.4 服务端重定向 我们在追加我们的评论后，需要跳转到我们的 / 主页，这是我们的 comments已经追加新数据， 在渲染的时候，自然就能将我们的新数据展现到我们的页面中。 关于重定向，此次有两部操作 12res.statusCode = 302res.setHeader('Location', '/') 第一步设置res请求的状态码，状态302 是临时重定向的状态码， 而后我们设置响应头的Location设置为 主页 访问别的页面：response.setStatus（302）; response.setHeader(“location”,”url”); 2.5 代码杂点笔记 模块加载在node中是同步的，通常把当前模块所有的依赖项都声明再文件模块最上面 为了让目录结构保持统一清晰，所以我们约定，把所有的 HTML 文件都放到 views（视图） 目录中，把所有的静态资源都存放在 public 目录中 ​ 浏览器收到 HTML 响应内容之后，就要开始从上到下依次解析， ​ 当在解析的过程中，如果发现： link script img iframe video audio ​ 等带有 src 或者 href（link） 属性标签（具有外链的资源）的时候，浏览器会自动对这些资源发起新的请求。 在这中服务端中，请求文件路径不要再去写相对路径了，因为这个时候所有的资源都是通过url来获取的，我们服务器开放了/public/目录，这里的静态资源的请求，如bootstrap.css都写为: &lt;link rel=&quot;stylesheet&quot; href=&quot;/public/lib/bootstrap/dist/css/bootstrap.css&quot;&gt; 浏览器在真正发请求的时候会最终把http://localhost:3000 拼在前面 3. 客户端3.1 客户端代码12345678910111213141516&lt;body&gt; &lt;div class="header container"&gt; &lt;div class="page-header"&gt; &lt;h1&gt;留言板 &lt;small&gt;--- a small demo of node&lt;/small&gt;&lt;/h1&gt; &lt;a class="btn btn-success" href="/post"&gt;发表留言&lt;/a&gt; &lt;hr&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="comments container"&gt; &lt;ul class="list-group"&gt; &#123;&#123;each comments&#125;&#125; &lt;li class="list-group-item"&gt;&#123;&#123;$value.name&#125;&#125;说: &#123;&#123;$value.message&#125;&#125;&lt;span class="float-right"&gt;&#123;&#123;$value.dataTime&#125;&#125;&lt;/span&gt;&lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel="stylesheet" href="/public/lib/bootstrap/dist/css/bootstrap.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="header container"&gt; &lt;div class="page-header"&gt; &lt;h1&gt;&lt;a href="/"&gt;首页&lt;/a&gt; &lt;small&gt;发表评论&lt;/small&gt;&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="comments container"&gt; &lt;!-- 以前表单是如何提交的？ 表单中需要提交的表单控件元素必须具有 name 属性 表单提交分为： 1. 默认的提交行为 2. 表单异步提交 action 就是表单提交的地址，说白了就是请求的 url 地址 method 请求方法 get post --&gt; &lt;form action="/pinglun" method="get"&gt; &lt;div class="form-group"&gt; &lt;label for="input_name"&gt;你的大名&lt;/label&gt; &lt;input type="text" class="form-control" required minlength="2" maxlength="10" id="input_name" name="name" placeholder="请写入你的姓名"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="textarea_message"&gt;留言内容&lt;/label&gt; &lt;textarea class="form-control" name="message" id="textarea_message" cols="30" rows="10" required minlength="5" maxlength="20"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;发表&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 所有的代码都在github仓库github代码]]></content>
      <categories>
        <category>Node</category>
        <category>Project</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总结Js中去重的几种方法]]></title>
    <url>%2F2018%2F09%2F24%2F%E6%80%BB%E7%BB%93Js%E4%B8%AD%E5%8E%BB%E9%87%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数组去重，中秋快乐。 ## 总结一下Js数组去重的几个方法 1. 双重for嵌套法123456789101112var removeDuplicates = function (arr) &#123; for (var i = 0; i &lt; arr.length - 1; i++) &#123; for (var j = i + 1; j &lt; arr.length; j++) &#123; if (arr[i] === arr[j]) &#123; arr.splice(j, 1); j--; &#125; &#125; &#125; return arr;&#125; 从第一项开始，把第一次循环的每个数都和后面的数进行比较，如果相等，就删掉后面的，这样一重循环下来，就能达到去重的效果。 2. indexOf方法去重 indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。 重要的是，这个方法，数组也有！ indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 123456789var removeDuplicates = function (arr) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr.indexOf(arr[i]) !== i) &#123; arr.splice(i, 1) i-- &#125; &#125; return arr;&#125; 3. 利用对象属性来去重先上代码： 1234567891011var removeDuplicates = function (arr) &#123; var res = []; var obj = &#123;&#125;; for (var i = 0; i &lt; arr.length; i++) &#123; if (!obj[arr[i]]) &#123; obj[arr[i]] = 1; res.push(arr[i]); &#125; &#125; return res;&#125;; 利用对象的属性在对象中只能存在一个的特征，我们可以新建一个对象，一个数组，循环遍历目标数组的每一项，检测到对象中没有当前循环数组的这一个属性时，我们就创建并随意赋予一个值（任意值都可以，因为我们关心的是属性名），将其属性名，也就是我们的数组项push到新数组中，最后返回新数组。 这样我们就能得到去重的新数组了！ 其中用到了对象的方括号表达式，这里就不在多说 4. ES6的set来实现 基本思路：ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。 1234var removeDuplicates = function (arr) &#123; var x = new Set(arr) return [...x]&#125; 短短两行代码，搞定，es6牛逼。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组去重</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 运行机制 & EventLoop]]></title>
    <url>%2F2018%2F09%2F20%2FJavaScript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[看阮老师博客和自己的理解，记录的学习笔记，js的单线程和 事件EventLoop 机制。 JavaScript 运行机制 &amp; EventLoop1. JavaScript是单线程 JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。 js这门语言在刚开始创造时，就是作为浏览器脚本语言，只要用途是与用户互动，操作dom，这决定了它只能为单线程，单线程已成为JavaScript这门语言的核心特征，将来也不会改变。 HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质 2. 任务队列单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着，导致很多时候CPU都是空闲着的。 JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。 于是，JavaScript任务可以分两种，同步任务和异步任务 同步任务同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。 异步任务异步任务指的是，不进入主线程，而进入任务队列中的任务，只有任务队列通知主线程，某个异步任务可以执行了，这个任务才会进入主线程执行。 异步执行的具体运行机制 同步执行也是如此，同步执行可以被视为没有异步任务的异步执行 所有同步任务都在主线程上执行，形成一个执行栈 主线程之外，还存在一个”任务队列”，只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 主线程不断重复上面的第三步。 只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。这个过程会不断重复。 3. 事件和回调函数Event queue - – 任务队列 是一个事件的队列，IO设备完成一项任务，就会在任务队列中添加一个事件，表明相关的异步任务可以进行“执行栈”了，主程序读取任务队列，就是读取里面的事件。 Event queue 中的事件，除了IO设备的事件，还包括一些用户的操作事件，如鼠标点击，页面滚动等等，只要指定过回调函数，这些事件都会进入任务队列，当主线程开始执行异步任务，就是执行对应的回调函数。 “任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。 但是，由于存在”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。 4. Event Loop 主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。 主程序运行时，产生堆和栈，栈中的代码调用各位外部的WEBAPI，他们在任务队列中加入各种事件，如图中的Click，Load，Done。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。 栈中的代码（同步任务）总是在任务队列（异步任务）之前执行 5. 定时器 除了放置异步任务的事件，”任务队列”还可以放置定时事件 定时器功能主要由setTimeout()和setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。以下主要讨论setTimeout()。 12setTimeout(function()&#123;console.log(1);&#125;, 0);console.log(2); 上面代码的执行结果总是2，1，因为只有在执行完第二行以后，系统才会去执行”任务队列”中的回调函数，尽管设置的推迟毫秒数为0. HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。 需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。 6. Node.js的Event Loop Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。 nodejs的event是基于libuv，而浏览器的event loop则在html5的规范中明确定义。 libuv已经对event loop作出了实现，而html5规范中只是定义了浏览器中event loop的模型，具体实现留给了浏览器厂商。 根据上图，Node.js的运行机制如下。 （1）V8引擎解析JavaScript脚本。 （2）解析后的代码，调用Node API。 （3）libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。 （4）V8引擎再将结果返回给用户。 除了setTimeout和setInterval这两个方法，Node.js还提供了另外两个与”任务队列”有关的方法：process.nextTick和setImmediate。它们可以帮助我们加深对”任务队列”的理解。 process.nextTick方法可以在当前”执行栈”的尾部—-下一次Event Loop（主线程读取”任务队列”）之前—-触发回调函数,它指定的任务总是发生在所有异步任务之前。 setImmediate方法则是在当前”任务队列”的尾部添加事件，也就是说，它指定的任务总是在下一次Event Loop时执行，这与setTimeout(fn, 0)很像。 1234567891011process.nextTick(function A() &#123; console.log(1); process.nextTick(function B()&#123;console.log(2);&#125;);&#125;);setTimeout(function timeout() &#123; console.log('Yo~~');&#125;, 0)// 1// 2// Yo~~ 上面代码中，由于process.nextTick方法指定的回调函数，总是在当前”执行栈”的尾部触发，所以不仅函数A比setTimeout指定的回调函数timeout先执行，而且函数B也比timeout先执行。这说明，如果有多个process.nextTick语句（不管它们是否嵌套），将全部在当前”执行栈”执行。 现在，再看setImmediate 12345678910setImmediate(function ()&#123; setImmediate(function A() &#123; console.log(1); setImmediate(function B()&#123;console.log(2);&#125;); &#125;); setTimeout(function timeout() &#123; console.log('TIMEOUT FIRED'); &#125;, 0);&#125;); 上面代码中，setImmediate与setTimeout(fn,0)各自添加了一个回调函数A和timeout，都是在下一次Event Loop触发。那么，哪个回调函数先执行呢？答案是不确定。运行结果可能是1–TIMEOUT FIRED–2，也可能是TIMEOUT FIRED–1–2。 令人困惑的是，Node.js文档中称，setImmediate指定的回调函数，总是排在setTimeout前面。实际上，这种情况只发生在递归调用的时候。 12345678910111213setImmediate(function ()&#123; setImmediate(function A() &#123; console.log(1); setImmediate(function B()&#123;console.log(2);&#125;); &#125;); setTimeout(function timeout() &#123; console.log('TIMEOUT FIRED'); &#125;, 0);&#125;);// 1// TIMEOUT FIRED// 2 上面代码中，setImmediate和setTimeout被封装在一个setImmediate里面，它的运行结果总是1–TIMEOUT FIRED–2，这时函数A一定在timeout前面触发。至于2排在TIMEOUT FIRED的后面（即函数B在timeout后面触发），是因为setImmediate总是将事件注册到下一轮Event Loop，所以函数A和timeout是在同一轮Loop执行，而函数B在下一轮Loop执行。 process.nextTick和setImmediate的一个重要区别：多个process.nextTick语句总是在当前”执行栈”一次执行完，多个setImmediate可能则需要多次loop才能执行完。 js 和 node 的原理知识还是很多地方都不甚了解，加油努力学习！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>EventLoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对常见的几种继承理解]]></title>
    <url>%2F2018%2F09%2F12%2F%E5%AF%B9%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BB%A7%E6%89%BF%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[继承是开发过程中很常用的流程，总结一下几种继承模式，包括最优的 圣杯继承 对常见的几种继承理解1. 传统形式 –&gt; 原型链1234567891011121314151617&lt;script&gt; Grand.prototype.lastName = "Kong" function Grand () &#123; &#125; var grand = new Grand () Father.prototype = grand function Father () &#123; &#125; var father = new Father() Son.prototype= father function Son () &#123; &#125; var son = new Son ()&lt;/script&gt; 这样从头继承到位，会发生一个问题，那就我不想继承的东西也会继承来，没得选择。影响效率。这种方法很快就被人废弃。 过多的继承了没用的属性 2. 借用构造函数1234567891011121314&lt;script&gt; function Person (name, age, sex) &#123; this.name = name this.sex = sex this.age = age &#125; function Student (name, age, sex, grade) &#123; Person.call(this, name, age, sex); this.grade = grade &#125; var student = new Student("Kong", 18, "male", "three")&lt;/script&gt; 在Student构造函数中，使用了Person构造函数并用call将this指向 指向了Student本身，这样Student构造函数就借用了Person构造函数来实现继承 但是这种情况下， 我们的new 出来的 student实例，不能借用构造函数Person的原型 另外我们每次构造一个实例，都要多走一个构造函数的流程，这样对也是不符合我们开发要求 但在开发过程中，如果一个构造函数涵盖了另外一个构造函数所有的属性和方法，这种方法需要的情况下也是可以使用的。 不能继承借用构造函数的原型 每次构造函数都要多走一个函数 3. 共享原型12345678910Father.prototype.lastName = "Kong"function Father () &#123;&#125;function Son () &#123;&#125;Son.prototype = Father.prototypevar son = new Son() 这样 Son 和 Father 的原型对象 指向了同一块地址如下 ​ Father.prototype ​ Father Son 现在将上面的继承方式封装成一个方法 123function inherit (Target, Origin) &#123; Target.prototype = Origin.prototype&#125; 执行inherit(Son, Father) 就能使Son和Father继承公有原型，这个时候Son和Father 构造出来的实例，都继承了同样的原型。 这样的模式，因为原型共享的缘故，不能在原型上添加自己的个性化属性和方法 4. 圣杯模式继承 第三种模式很好，但是缺点是不能在原型上添加私有的属性方法，那么我们可不可以有一种方式，创建一个走早函数，既能拥有别人的原型，又可以在继承的原型上添加自己的个性化东西，我们可以使用 我们的 圣杯继承 我们可以使用 复制 这一个思想 能否保存一个原型的拷贝，给我们的继承者，这样我们在就能在拷贝份上添加自己的东西。 先看代码 1234567891011121314151617Father.prototype.lastName = "Kong"function Father () &#123;&#125;function Son () &#123;&#125;function inherit (Target, Origin) &#123; function F() &#123;&#125;; F.prototype = Origin.prototype Target.prototype = new F()&#125;inherit(Son, Father)var son = new Son()var father = new Father() 代码inherit继承函数中，我们想定义一个构造函数 F ，作为一个临时转换的作用，将要继承的构造函数的原型对象赋值给F的原型对象，之后让被继承的构造函数的原型指向 new 的 F 的实例，这样 就能实现原型的继承 此时在Son.prototype.__proto__ === Father.prototype // True 我们在Son.prototype 上添加了一个Son的私有属性， Son.prototype.age = 18 访问我们的 son.age // 18 而 访问 father.age // undefined 此时这种继承模式已经很好了，但是还存在一点瑕疵 我们都知道构造函数的原型都有一个 constructor属性指向这个构造函数本身 比如访问 Father.prototype.constructor –&gt; ƒ Father() {} 我们访问 Son.prototype.constructor – &gt; ƒ Father() {} 这是由于我们的Son.prototype是由Father.prototype继承而来的，所以也就继承了Father.prototype的constructor属性. 下面我应该让Son的constructor属性归位 1234567function inherit (Target, Origin) &#123; function F() &#123;&#125;; F.prototype = Origin.prototype Target.prototype = new F() Target.prototype.constuctor = Target // constuctor归位 Target.prototype.uber = Origin.prototype // 超类储存&#125; 在函数加了一行代码，是目标构造函数的 constuctor 归位 这样我们访问Son.prototype.constuctor –&gt; ƒ Son() { } 而最后加的一行代码是为了储存我们的构造函数到底继承自哪个原型 上面的 inherit函数 就是我们的最完美的继承方法，圣杯模式 我们还可以将上面代码优化一下 123456789var inherit = (function () &#123; var F = function () &#123;&#125; return function (Target, Origin) &#123; F.prototype = Origin.prototype Target.prototype = new F() Target.prototype.constuctor = Target // constuctor归位 Target.prototype.uber = Origin.prototype // 超类储存 &#125;&#125;()) 将过渡的F放在了闭包里，避免了全局变量的污染，实现了属性的私有化 早期的雅虎封装的继承函数就是采用的这种形式 以上就是我通过学习关于继承的几种方式的理解。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>原型继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型中的prototype和__proto__]]></title>
    <url>%2F2018%2F09%2F11%2F%E5%8E%9F%E5%9E%8B%E4%B8%AD%E7%9A%84prototype%E5%92%8C-proto%2F</url>
    <content type="text"><![CDATA[之前初学JavaScript的时候，被这两个东西搞得迷迷糊糊的，前两天看JS高程的时候，看到了prototype，自己好好的总结了一下 谈谈对prototype和__proto__的理解1. 构造函数，原型对象，实例构造函数的原型属性 prototype指向了原型对象，在原型对象有的属性和方法，构造函数构造出的实例都可以继承共享，不是很恰当的说，如果构造函数是实例的爹，那么原型对象就是构造函数的爹，也就是实例爹的爹，爷爷。 构造函数是函数 原型对象的对象 实例也是是对象 以下列代码为例： 12function Foo () &#123;&#125;foo = new Foo () 上面代码创造了一个构造函数，并new了一个Foo的实例foo，我们可以在控制台打印下面代码 可以很明显看到，Foo构造函数是一个function，而foo实例和Foo.prototype原型对象都是对象 2. 关系示意图 3. 详解 prototype 是属于一个函数特有的属性，而 __proto__一般存在于对象之中 Foo函数作为一个构造函数，它的的prototype指向它的原型，Foo.prototype是一个对象，里面的属性和方法能传给Foo构造的实例之中。 而Foo.prototype这的对象有一个属性 为 constructor （构造器属性），constructor属性指向原型对象对应的构造函数，也就是指向 Foo foo.constructor --&gt; ƒ Foo() {} 对象具有__proto__ 可称为隐式原型，一个对象的隐式原型，指向构造改对象(foo)的构造函数(Foo)的原型(Foo.prototype)，这也保证了实例能够访问继承构造函数原型对象中的属性和方法 所以，foo.__porto__ === Foo.prototype 对象没有prototype属性，所以 foo.prototype = undefined 但是函数可以有__proto__属性，因为函数的本质也是一个对象 Foo是一个方法，既一个函数，函数本身也是一个特殊的对象，把Foo作为一个对象来看，它的__proto__指向Foo构造函数本身的构造函数的原型，Foo构造函数的构造函数是是Function Foo.constructor --&gt; ƒ Function() { [native code] } (后者即是Function) Foo.constructor === Function // true Foo.constructor.prototype === Foo.__proto__ // true Function.prototype === Foo.__proto__ // true 原型对象是对象，也有__proto__属性，我们可以在控制台打印 Foo.prototype.__proto__发现出现了一个对象，里面有很多属性 包括 constructor， hasOwnProperty， isPrototypeOf，等等的方法 其实这个对象就是Object.prototype， 而Object就是这个原型对象的构造函数 这里的Object是一个构造函数，不是一个对象，不要搞错，typeof(Object) –&gt; function 最后我们看一下Object.prototype这个对象的__proto__属性，我们会发现为Null Object.prototype.__proto__ // null Function.prototype === Function.__proto__ // true Function的原型和Function的__proto__竟然全等，构造Function的构造函数的原型 等于 Function的原型 我们发现一个有趣的东西 Function 是由 Function 构造的 ，Function可以看成是调用其自身的new操作的实例化的结果，哈哈 有点意思，没爹，自己把自己搞出来了。。 我们接着试探，发现Function.prototype当做一个对象来看，他的构造函数是Object( )函数，那么Function.prototype.__proto也就是Object的原型了 所以 Function.prototype.__proto__ ===Object.prototype // true 4. 总结 对象有属性proto,指向该对象的构造函数的原型对象 方法除了有属性proto,还有属性prototype，prototype指向该方法的原型对象 函数(Function也是函数)是new Function的结果，所以函数可以作为实例对象，其构造函数是Function()，原型对象是Function.prototype 对象(函数也是对象)是new Object的结果，所以对象可以作为实例对象，其构造函数是Object()，原型对象是Object.prototype Object.prototype的原型对象是null]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>原型继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读阮一峰Flex 学习笔记]]></title>
    <url>%2F2018%2F09%2F09%2F%E8%AF%BB%E9%98%AE%E4%B8%80%E5%B3%B0%E8%80%81%E5%B8%88flex%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[最近在学习flex，看到阮一峰老师的博客有详细的关于flex的介绍，看着博客，记录下flex学习的笔记。 flex笔记 - 基础文章中的所有图示代码都放在了github上： 阮一峰flex博客跟学代码 传统的布局解决方案，基于盒模型， 依赖 display, position, float属性来进行布局，有的时候很不方便，实现垂直居中就很不方便。 一. Flex简介Flex 是 Flexible Box 的缩写，译为弹性布局，用来为盒模型提供最大的灵活性。 任何一个容器都可以使用 Flex 布局 元素设置为Flex布局后，子元素的 float,clear, vertical-align 属性将失效 二. 基本概念采用Flex布局的元素，为Flex容器，它所有的子元素自动成为容器成员，成为Flex成员，（flex item） 一个flex布局存在两根轴，水平横轴，也叫主轴（即图中的 main axis) 和 垂直纵轴 （cross axis） 横轴的开始位置，也就是图中左边框上的点集合， 叫做main start，结束位置，图中右边框的点集合，叫做main end，垂直纵轴的开始位置（上边框的点）叫做cross start，结束位置，下边框的点，叫做cross end， 每一个成员item的水平空间和垂直空间分别为 main size和 cross size 三. 容器属性 接下来的展示demo github项目中的代码为了方便有些属性写在了item成员上，最正确的方式是些在flex容器上。 1. flex-directionflex-direction属性决定水平横轴的方向（即项目的排列方向）。 它可取以下四个值 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 2. flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 它可取三个值 nowrap（默认）：不换行 wrap：换行，第一行在上方 wrap-reverse：换行，第一行在下方 如图我们可以发现，默认的nowrap属性的优先级是高于我们设置的width的。 3. flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap 4. justify-content属性justify-content属性定义了项目在水平横轴上的对齐方式 阮老师的博客图示： 属性能取5个值 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 5. align-items属性align-items属性定义项目在垂直纵轴上如何对齐。 和justify-content属性一块记忆比较容易。 它可能取5个值 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 下图示例是的垂直纵轴方向是由上到下 6. align-content属性align-content属性定义了多根轴线的对齐方式。 align-content只适用于多行 的flex容器 该属性可能取6个值 flex-start：与垂直轴的起点对齐。 flex-end：与垂直轴的终点对齐。 center：与垂直轴的中点对齐。 space-between：与垂直轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个垂直轴。 四. item成员的属性1. order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0 2. flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 3. flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4. flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 5. flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 6. align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>Flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo同步，npm源的修改]]></title>
    <url>%2F2018%2F09%2F07%2Fhexo%E5%90%8C%E6%AD%A5%EF%BC%8Cnpm%E6%BA%90%E7%9A%84%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[在同步hexo的时候遇到的一些小问题，以及解决办法. hexo 同步 hexo next 搭建了一个个人博客，考虑到多电脑操作，通过使用git来同步配置文件和代码，实现hexo的同步 在已建成的hexo目录下执行命令 git init git add . git commit -m &quot;message&quot; git push hexo中自带gitignore文件，避免了无用文件的上传 在另一台电脑上 安装node npm i hexo --g 新建博客根目录文件夹 如 hexo 在hexo根目录下 git init git pull xxxxx 远程仓库的地址 npm i git clone 和 git pull 的区别 两者都是从仓库拉取到本地，但是其中有什么区别 git clone 是本地没有仓库的时候，将远程的仓库整个下载下来，是远程操作的第一步。 git pull 是当本地有仓库的时候，将远程仓库里新的 commit 数据 下载下来 并将其 merge git pull = git fetch + git merge npm 源 的修改在上面的hexo init 的过程中，装包的时候多次卡住不动不进展，我们需要修改npm源 在国内不翻墙的情况下 官方的npm 有的时候会丢包严重，装包过程中卡主不动，我们可以修改npm 的下载源，将其改为中国的淘宝镜像，这样就可以解决问题了 使用taobao镜像不是必须要安装cnpm，我们可以通过配置对应的registry来达到同样的效果 进入 cmd 输入下列命令，配置registry npm config set registry https://registry.npm.taobao.org 配置后可通过下面方式来验证是否成功 npm config get registry 这样就可以快速的装包了]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-music项目笔记(1)]]></title>
    <url>%2F2018%2F08%2F25%2Fvue-music-1%2F</url>
    <content type="text"><![CDATA[跟学一个vue-music 音乐播放器实战教程，记录的笔记以及项目注意事项，细节。 Vue-Music 一| 前期工作1.项目初始化 npm install -g vue-cli vue init webpack vue-music npm install stylus stylus-loader -D 修改eslint.js 修改webpack.base.conf.js resolve配置项简化路径 2.装包 npm install fastclick –save 取消默认300ms延迟 12import fastClick from 'fastclick'fastClick.attach(document.body) npm install babel-polyfill对es6的高级语法进行转义当运行环境中并没有实现的一些方法，babel-polyfill 会给其做兼容需要在main.js中引入 npm install babel-runtime –save 辅助编译 不需要引入即可用 babel-runtime 是供编译模块复用工具函数。是锦上添花babel-polyfil是雪中送炭，是转译没有的api. 二| 顶部tab导航 &amp;&amp; Recommend 页面组件开发1. 顶部导航栏 tab建立基本的页面骨架，基本的组件引入header rank recommend search singer tab 这几个组件组成页面骨架 2. recommend组件 数据获取qq音乐 Jsonp Jsonp发送的不是一个ajax请求，他动态创建一个script标签，script没有同源策略限制，所以能跨域 有一个返回参数 callback ， 后端解析url，返回一个方法。 安装： npm install jsonp@0.2.1jsonp github仓库 以后需要多出引用jsonp跨域请求，将其创建在 scr/common/jsonp.js 中 jsonp promise化123456789101112131415161718192021222324252627import originJSONP from 'jsonp'export default function jsonp(url, data, option) &#123; // jsonp的三个参数 // - url--&gt;一个纯净的url地址 // - data --&gt; url中的 query 通过 data 拼到url上 // - option url += (url.indexOf('?') &lt; 0 ? '?' : '&amp;') + param(data) return new Promise((resolve, reject) =&gt; &#123; originJSONP(url, option, (err, data) =&gt; &#123; if (!err) &#123; resolve(data) &#125; else &#123; reject(err) &#125; &#125;) &#125;)&#125; // 拼接data到urlfunction param (data) &#123; let url = '' for (var k in data) &#123; let value = data[k] !== undefined ? data[k] : '' url += `&amp;$&#123;k&#125;=$&#123;encodeURIComponent(value)&#125;` &#125; // encodeURIComponent() 函数可把字符串作为 URI 组件进行编码。 return url ? url.substring(1) : ''&#125; 注意：当路径报错的时候，我们要想到webpack.base.conf.js配置文件中的 alias 选项 确保路径是否匹配 Recommend的数据获取 在 recommend.vue 中的 created 生命周期钩子中调用_getRecommend 方法 _getRecommend 方法调用recommend.js中暴露出来的getRecommend方法 而 getRecommend 方法调用了 Jsonp 方法， Jsonp方法抓取接口，从而获得数据 有的jsonp接口url很长，但是真正的url知识前面的部分 大公司一般用0来代表一切正常 轮播图组件 轮播图数据获取完成后，就下来做的就是搭建轮播页面 ，接下来编写一个轮播组件 slider.vue 新建base文件夹，储存如同slider.vue的基础组件在silder.vue中，我们使用了slot插槽，外部引用slider的时候slider标签里面包裹的dom会被插入到slot插槽部分。 在recommend.vue中 引入 import Slider from &#39;base/slider/slider&#39;,并在components中注册Slider，之后就可以使用Slider标签了 将jsonp返回的slider数据存储到recommend数组中，然后遍历recommned 数组项循环渲染内容 这个时候我们打开项目，会发现已有数据，但是样式还不行，在props中添加loop，autoplay，interval（滚动间隔）， 使用了第三方轮播 better-scroll 来进一步实现 slider 新版的BS中snap属性集合成了一个对象选项 而旧版的是单独的属性名，这点要注意 初始化BS，在什么时候初始化？我们要保证渲染的时机是正确的，通常在mounted生命周期钩子中初始化，保证BS正常渲染的话我们通常在mounted里面加一个延迟123456mounted () &#123; setTimeout(() =&gt; &#123; // 浏览器17ms刷新一次， 这里延迟20ms 确保组件已经渲染完成 this._setSliderWidth() // 设置slider宽度 this._initDots() // 初始话dots this._initSlider() // 初始化slider &#125;, 20) _setSliderWidth方法 – 轮播图组件的宽度计算这里要注意，这时候执行玩宽度方法之后，可能无效，这是因为在宽度计算的时候，slot插槽里面的东西还未加载，为了解决这个问题，我们可以在recommend.vue中 给slider 的父元素 加上v-if=&quot;recommends.length&quot;,确保渲染时机正确 _initSlider()方法 – 使用new BScroll 创建轮播实例，设置无限滚动及其他的相关初始化配置，至此，我们的轮播页面已经可以无缝滚动了 添加dots导航 五个数据，dom有七个，因为loop为ture的时候，bs会自动在前后各拷贝一份。我们想要添加dots，必须保证和数据数一样，所以我们应该在bs初始化之前完成dots的初始化 初始化dots为一个长度为childern.length的数组 this.dots = new Array(this.children.length) 在slider.vue中循环 v-for=&quot;(item,index) of dots&quot; 添加选中样式 :class=&quot;{active:currentPageIndex === index}&quot; 在bs滚动的时候 会派发一个事件 在初始化slider 绑定一个事件 1234567891011 this.slider.on('scrollEnd', () =&gt; &#123; let pageIndex = this.slider.getCurrentPage().pageX if (this.loop) &#123; pageIndex -= 1 this.currentPageIndex = pageIndex if (this.autoplay) &#123; clearTimeout(this.timer) this._play() &#125; &#125;&#125;) 使用了 bs中的 getCurrentPage 方法来获取滚动的当前页面 在autoplay中使用了bs 的 goToPage 方法来实现轮播 监听窗口大小改变自动改变 &amp;&amp; 优化slider 之前的slider基本完成，但是此时如果改变窗口大小，页面就会乱掉 使用resize窗口监听事件，配合bs的refresh刷新方法 实现每一次改变窗口大小都能重置宽度1234567window.addEventListener('resize', () =&gt; &#123; if (!this.slider) &#123; // slider还没有初始化的时候 return &#125; this._setSliderWidth(true) this.slider.refresh()&#125;) 在app.vue 中使用keepalive标签，来避免重复请求 我们在跳转到其他页面的时候，要记得清理定时器，优化效率123destroyed() &#123; clearTimeout(this.timer) // 性能优化小习惯&#125; 歌单组件歌单组件数据获取在pc版的qq音乐中获取请求接口 由于QQ音乐的歌单数据时，请求接口host和refer规定了必须是qq音乐的地址，我们本地就会请求失败。为了解决这个问题，我们可以使用 手动代理 伪装成qq音乐地址请求接口 欺骗接口 Vue proxyTable代理 后端代理接口 在项目开发的时候，接口联调的时候一般都是同域名下，且不存在跨域的情况下进行接口联调，但是当我们现在使用vue-cli进行项目打包的时候，我们在本地启动服务器后，比如本地开发服务下是 http://localhost:8080 这样的访问页面，但是我们的接口地址是 http://xxxx.com/save/index 这样的接口地址，我们这样直接使用会存在跨域的请求，导致接口请求不成功，因此我们需要在打包的时候配置一下，我们进入 config/index.js 代码下如下配置即可： 123456789101112131415161718192021dev: &#123; // 静态资源文件夹 assetsSubDirectory: 'static', // 发布路径 assetsPublicPath: '/', // 代理配置表，在这里可以配置特定的请求代理到对应的API接口 // 例如将'localhost:8080/api/xxx'代理到'www.example.com/api/xxx' // 使用方法：https://vuejs-templates.github.io/webpack/proxy.html proxyTable: &#123; '/': &#123; target: 'https://c.y.qq.com', // 接口的域名 secure: false, // 如果是https接口，需要配置这个参数 changeOrigin: true, // 如果接口跨域，需要进行这个参数配置 pathRewrite: &#123; '^/api': '/' &#125;, headers: &#123; referer: 'https://c.y.qq.com' &#125; &#125; &#125; 注意： ‘/api’ 为匹配项，target 为被请求的地址，因为在 ajax 的 url 中加了前缀 ‘/api’，而原本的接口是没有这个前缀的，所以需要通过 pathRewrite 来重写地址，将前缀 ‘/api’ 转为 ‘/‘。如果本身的接口地址就有 ‘/api’ 这种通用前缀，就可以把 pathRewrite 删掉。 表单组件开发我们通过代理获得ajax数据后，将其赋值给 discListthis.discList = res.data.list之后将disclist渲染到组件中v-for=&quot;item of discList&quot; 滚动组件 Scroll.vue由于 滚动 是一个很基础的组件 所以在common里创建scroll.vue组件，使代码结构化12345&lt;template&gt; &lt;div ref=&quot;wrapper&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 在Recommend.vue中 一定要绑定data数据，因为scroll.vue中 watch 监听data数据的变化来刷新better-scroll 这里的可以绑定recommend.vue中的 discList 数组来座位 data 这里的 recommends 和 discList 数据获取是有先后顺序的，一般都是先recommends再discList，如果先获取到的是discList的话 歌单列表就会出现滚动不到底部的问题 为了确保recommend数据后加载的情况下我们的表单还能正常滚动发，我们可以给slider中的img添加一个loadImage方法@load=&quot;loadImage&quot;，方法调用一个 refresh方法即可 this.$refs.scroll.refresh()为了避免请求的每一张图片都执行一次，我们可以设置一个bool标志位来控制 ，只要有一张图片加载完成即可，如下：123456loadImage() &#123; if (!this.checkLoaded) &#123; this.$refs.scroll.refresh() this.checkLoaded = true &#125;&#125; 表单组件优化 图片的懒加载 节省流量，提升加载速度npm 安装npm install vue-lazyload在main.js中添加代码 1234import VueLazyLoad from 'vue-lazyload'Vue.use(VueLazyLoad, &#123; loading: require('common/images/touxiang.png')&#125;) 在Recommend.vue中使用&lt;img v-lazy=&quot;item.imgurl&quot; alt=&quot;&quot;&gt; 解决图片点击失效有些情况下点击事件之间互相冲突，我们在使用fastclick的时候，可以给点击的dom添加一个fastclick里的一个css needsclick的类名，来确保点击事件可以正常执行 loading组件为了增加交互体验，在表单还未渲染之前，我们可以使用一个loading来占位。 在base中新建loading组件1234567891011121314151617&lt;template&gt; &lt;div class="loading"&gt; &lt;img src="./loading.gif" alt=""&gt; &lt;p class="desc"&gt;&#123;&#123;title&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; title: &#123; type: String, default: '许文瑞正在吃屎。。。。' &#125; &#125;&#125;&lt;/script&gt; 在recommend.vue中添加如下代码：123&lt;div class="loading-content" v-show="!discList.length"&gt; &lt;loading&gt;&lt;/loading&gt;&lt;/div&gt; 三| 歌手组件开发1.歌手首页开发数据获取 数据获取依旧从qq音乐官网获取 歌手接口 创建singer.js 我们和以前一样，利用我们封装的jsonp等发放，来请求我们的接口，返回给singer.vue。 成功获取数据以后，我们发现，官网的数据的数据结构和我们想要的不一样，所以我们下一步进行数据结构的聚合处理 数据处理我们希望的数据结构是数据按照字母排序的数组再加上一个热门的数组的集合，显然我们在官网的到的数据不是这样的，我们构造一个_normalizeSinger方法来完成： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546_normalizeSinger(list) &#123; // 处理数据结构 形参为list let map = &#123; // 把数据都存在map对象中 hot: &#123; // 热门城市 title: HOT_NAME, items: [] // 初始化空数组 &#125; &#125; list.forEach((item, index) =&gt; &#123; // 循环数组中的每一项 if (index &lt; HOT_SINGER_LENGTH) &#123; // 因为原始数据是按照热度排列的，所以获取前十的热门 map.hot.items.push(new Singer(&#123; // push到我们的hot数组中 // new Singer: 为了模块化和减少代码的复用，我们在common &gt; js 创建了一个singer.js // 来创建一个类构造器 里面包括歌手头像的拼接 id: item.Fsinger_mid, name: item.Fsinger_name &#125;)) &#125; const key = item.Findex // 歌手姓氏字首字母 if (!map[key]) &#123; // 如果不存在 map[key] = &#123; // 创建 title: key, items: [] &#125; &#125; map[key].items.push(new Singer(&#123; // 追加到map.items中 id: item.Fsinger_mid, name: item.Fsinger_name &#125;)) &#125;) // 为了得到有序列表 我们需要处理map let hot = [] // 热门城市 let ret = [] // 字母表城市 for (let key in map) &#123; // 循环 let val = map[key] if (val.title.match(/[a-zA-Z]/)) &#123; // 正则匹配字母 ret.push(val) &#125; else if (val.title === HOT_NAME) &#123; hot.push(val) // 热门城市 &#125; &#125; ret.sort((a, b) =&gt; &#123; return a.title.charCodeAt(0) - b.title.charCodeAt(0) // 把字母城市按charcode字母排序 &#125;) return hot.concat(ret) // 将字母城市追加到hot城市 返回给外部 &#125; 细节点注意 关于歌手图片的获取，通过官网观察，我们发现图片是有一个网址拼接item.Fsinger_mid 来完成的，所以我们在common &gt;js &gt;singer.js中 使用了${}来拼接，获取歌手图片地址，拼接url语法是使用的是 而不是’ ‘ listview.vue开发数据我们获取到了，我们接下来开发listview.vue组件，因为这个列表组件我们后面有很多页面也要用到，所以我们在base下创建基础组件 listview.vue 在listview.vue中引入 我们之前封装好的scroll组件import Scroll from &#39;base/scroll/scroll&#39; 通过获取的数据，进行两次遍历渲染，就能得到我们想要的dom页面了 html代码如下 12345678910111213141516171819202122&lt;template&gt; &lt;scroll class="listview" :data="data"&gt; &lt;ul&gt; &lt;li v-for="(group, index) in data" :key="index" class="list-group"&gt; &lt;h2 class="list-group-title"&gt;&#123;&#123;group.title&#125;&#125;&lt;/h2&gt; &lt;ul&gt; &lt;li v-for="(item, index) in group.items" :key="index" class="list-group-item"&gt; &lt;img v-lazy="item.avatar" class="avatar"&gt; &lt;span class="name"&gt;&#123;&#123;item.name&#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class="list-shortcut"&gt; &lt;ul&gt; &lt;li class="item" v-for="(item, index) in shortcutList" :key="index"&gt; &#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/scroll&gt;&lt;/template&gt; 至此 歌手页面就能正常滚动了 shortcutList字母导航器接下来，开始我们的字母导航器的样式制作 我们可以在listview.vue中创建一个计算属性shortcutList 1234567computed: &#123; shortcutList() &#123; return this.data.map((group) =&gt; &#123; return group.title.substr(0, 1) &#125;) &#125; &#125;, 之后在页面中v-for渲染shortcutList即可 配合css样式 实现边栏的字母导航dom的制作 1234567891011121314151617&lt;div class="list-shortcut" @touchstart="onShortcutTouchStart" @touchmove.stop.prevent="onShortcutTouchMove"&gt; &lt;ul&gt; &lt;li class="item" v-for="(item, index) in shortcutList" :key="index" :data-index="index" :class="&#123;'current': currentIndex === index&#125;" &gt; &#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 静态的字母导航在页面中已经展现出来了 接下来 来给导航器添加滑动点击等事件，使其动态化 滑动右边字母导航 listview实时滚动 在字母html标签中加入touch事件** 12@touchstart=&quot;onShortcutTouchStart&quot;@touchmove.stop.prevent=&quot;onShortcutTouchMove&quot; 在循环中遍历index值，在后面的touch中获取索引，由于蕾类似此类获取数据的方法是很多地方都能用到的，我们在dom.js中添加getData方法 123456789export function getData(el, name, val) &#123; const perfix = &apos;data-&apos; name = perfix + name if (val) &#123; return el.setAttribute(name, val) &#125; else &#123; return el.getAttribute(name) &#125;&#125; 接下来 为scroll组件添加 跳转方法 12345scrollTo() &#123; this.scroll &amp;&amp; this.scroll.scrollTo.apply(this.scroll, arguments) &#125;, scrollToElement() &#123; this.scroll &amp;&amp; this.scroll.scrollToElement.apply(this.scroll, arguments) 完整的touch方法代码如下： 1234567891011121314onShortcutTouchStart(e) &#123; let anchorIndex = getData(e.target, 'index') // 获取data let firstTouch = e.touches[0] // 刚开始触碰的位置坐标 this.touch.y1 = firstTouch.pageY this.touch.anchorIndex = anchorIndex this._scrollTo(anchorIndex) // 通过使用_scrollTo方法来跳转到我们的字母所在位置 &#125;, onShortcutTouchMove(e) &#123; // 屏幕滑动方法 要明确开始滚动和结束滚动的两个位置，然后计算出滚动到哪一个字母 let firstTouch = e.touches[0] // 停止滚动时的位置坐标 this.touch.y2 = firstTouch.pageY // 保存到touch对象中 let delta = (this.touch.y2 - this.touch.y1) / ANCHOR_HEIGHT | 0 // 计算滚动了多少个字母 let anchorIndex = parseInt(this.touch.anchorIndex) + delta // this.touch.anchorIndex 字符串转化为整型 this._scrollTo(anchorIndex) // 跳转到字母位置 &#125; 注意：通过getData方法的到的anchorIndex是一个字符串，记得要用parseInt转化为数字 至此 滑动字母导航器 左边的list已经可以实现滚动了 滚动左边list 右边字母导航高亮 解决这个问题 ，就要知道左边listview滚动到的相对位置 在data中增加scrollY 和 currentIndex来实时监听listview滚动的位置 和 应该滚动到的具体索引 在scroll标签组件绑定@scroll=’scroll’ 来将滚动的实时位置赋值给this.scrollY 1234scroll(pos) &#123; this.scrollY = pos.y console.log(pos) // 测试&#125; 在listview中添加监视属性data 123456watch: &#123; data() &#123; setTimeout(() =&gt; &#123; // 数据变化到dom变化有一个延迟，所以这个加一个定时器 this._calculateHeight() // 计算每一个group的高度 &#125;, 20) &#125; 每次data变化，都会重新计算group的高度 _calculateHeight方法 1234567891011_calculateHeight() &#123; this.listHeight = [] const list = this.$refs.listGroup let height = 0 this.listHeight.push(height) for (let i = 0; i &lt; list.length; i++) &#123; let item = list[i] height += item.clientHeight this.listHeight.push(height) // 得到一个包含每一个group高度的数组 &#125;&#125; 这样 就能得到一个包含所有grroup高度的一个数据 在watch里监听scrollY 拿到了每组的位置，我们可以监听scrollY 联合两者判断字母导航器应该滚动到的位置 123456789101112131415161718192021scrollY(newY) &#123; const listHeight = this.listHeight // 当滚动到顶部 newY &gt; 0 if (newY &gt; 0) &#123; this.currentIndex = 0 return &#125; // 在中间部分滚动 for (let i = 0; i &lt; listHeight.length; i++) &#123; let height1 = listHeight[i] let height2 = listHeight[i + 1] if (-newY &gt;= height1 &amp;&amp; -newY &lt; height2) &#123; this.currentIndex = i this.diff = height2 + newY // 注意 newY为负值 return &#125; &#125; // 当滚动到底部，且-newY 大于最后一个元素的上线 this.currentIndex = listHeight.length - 2&#125; currentIndex 绑定类 实现字母高亮 :class=&quot;{&#39;current&#39;: currentIndex === index}&quot; ​ 细节优化 完善_scrollTo方法 123456789101112_scrollTo(index) &#123; if (!index &amp;&amp; index !== 0) &#123; // 点击以外的部分 无反应 return &#125; if (index &lt; 0) &#123; // 滑动到顶部时 index为负 index = 0 &#125; else if (index &gt; this.listHeight.length - 2) &#123; // 滑动到尾部 index = this.listHeight.length - 2 &#125; this.scrollY = -this.listHeight[index] // 每次点击都更改scrollY以实现同步 this.$refs.listview.scrollToElement(this.$refs.listGroup[index], 300)&#125; fixedTitle 计算属性 123456fixedTitle() &#123; if (this.scrollY &gt; 0) &#123; return '' &#125; return this.data[this.currentIndex] ? this.data[this.currentIndex].title : ''&#125; 页面html 123&lt;div class="list-fixed" v-show="fixedTitle" ref="fixed"&gt; &lt;h1 class="fixed-title"&gt;&#123;&#123;this.fixedTitle&#125;&#125;&lt;/h1&gt;&lt;/div&gt; 至此 顶部的fixedtitle标题就做好了 但是我们发现两个title在重合的时候 并不是很完美，下面我们就来添加一个顶上去的动画来优化 在scrollY函数中 我们可以轻松获取一个 diff 值 this.diff = height2 + newY // 注意 newY为负值 通过监听diff 我们可以来实现我们的要求 12345678diff(newVal) &#123; let fixedTop = (newVal &gt; 0 &amp;&amp; newVal &lt; TITLE_HEIGHT) ? newVal - TITLE_HEIGHT : 0 if (this.fixedTop === fixedTop) &#123; return &#125; this.fixedTop = fixedTop this.$refs.fixed.style.transform = `translate3d(0,$&#123;fixedTop&#125;px,0)`&#125; 2.歌手详情页 歌手详情使用二级子路由来开发 字路由 / 二级路由设置 路由是由组件承载的 在router – index.js中 写入代码 添加字路由 1234567891011&#123; path: '/singer', name: 'Singer', component: Singer, children: [ &#123; path: ':id', component: SingerDetail &#125; ] &#125; 如代码所示，在Singer component组件路由选项中，添加children 实现二级路由，然后需要在页面上加上router-view 标签来挂在这个二级路由显示页面 编写跳转逻辑 在次页面中，二级路由的跳转是在listview.vue中通过点击事件向外派发事件来实现的 123selectItem(item) &#123; this.$emit('select', item) // 向外派发事件&#125; 因为listview.vue是一个基础组件，不会编写业务逻辑，所以把点击事件派发出去，让外部实现业务逻辑的编写 在singer.vue 中，我们监听到这个派发出来的select &lt;list-view :data=&quot;singers&quot; @select=&quot;selectSinger&quot;&gt;&lt;/list-view&gt; 然后在selectSinger方法里面使用vue-router的 编程式跳转接口 12345selectSinger(singer) &#123; this.$router.push(&#123; path: `/singer/$&#123;singer.id&#125;` // 跳转页面 &#125;) &#125; 添加转场动画将singer-detail.vue 组件用transition标签包裹 并在css中添加动画 1234.slide-enter-active, .slide-leave-active transition: all 0.3s .slide-enter, .slide-leave-to transform: translate3d( 0, 100%, 0) 就下来，开始正式开发singer-detail组件,在这之前，我们先了解一下Vuex 跳转到vuex笔记 获取singer-detail数据12345678910111213141516export function getSingerDetail(singerId) &#123; const url = 'https://c.y.qq.com/v8/fcg-bin/fcg_v8_singer_track_cp.fcg' const data = Object.assign(&#123;&#125;, commonParams, &#123; hostUin: 0, needNewCode: 0, platform: 'h5page', order: 'listen', begin: 0, num: 50, songstatus: 1, g_tk: 649509476, singermid: singerId // 注意是mid而不是id 不要出错 &#125;) return jsonp(url, data, options)&#125; 当在singer-detail页面上刷新的时候，会获取不到数据，因为我们的数据是通过跳转得到的，如果我们在singer-detail数据上刷新，将返回上一级signer this.$router.push(&#39;/singer&#39;) 整理获取的数据结构common&gt;js&gt;song.js 123456789101112131415161718192021222324252627282930313233343536export default class Song &#123; constructor(&#123;id, mid, singer, name, album, duration, image, url&#125;) &#123; this.id = id this.mid = mid this.singer = singer this.name = name this.album = album this.duration = duration this.image = image this.url = url &#125;&#125;export function createSong(musicData) &#123; return new Song(&#123; id: musicData.songid, mid: musicData.songmid, singer: filterSonger(musicData.singer), name: musicData.songname, album: musicData.albumname, duration: musicData.interval, image: `https://y.gtimg.cn/music/photo_new/T002R300x300M000$&#123;musicData.albummid&#125;.jpg?max_age=2592000`, url: `http://ws.stream.qqmusic.qq.com/C100$&#123;musicData.songmid&#125;.m4a?fromtag=0&amp;guid=126548448&amp;crazycache=1` &#125;)&#125;function filterSonger(singer) &#123; let ret = [] if (!singer) &#123; return '' &#125; singer.forEach((s) =&gt; &#123; ret.push(s.name) &#125;) return ret.join('/')&#125; 通过方法调用类构造器，我们就能通过createSong(musicData)来整理获得我们需要的结构数据 singer-detail 1234567891011121314151617181920212223methods: &#123; _getDetail() &#123; if (!this.singer.id) &#123; this.$router.push('/singer') &#125; getSingerDetail(this.singer.id).then((res) =&gt; &#123; if (res.code === ERR_OK) &#123; console.log(res.data.list) this.songs = this._normalizeSongs(res.data.list) &#125; &#125;) &#125;, _normalizeSongs(list) &#123; let ret = [] list.forEach((item) =&gt; &#123; let &#123;musicData&#125; = item if (musicData.songid &amp;&amp; musicData.albummid) &#123; ret.push(createSong(musicData)) &#125; &#125;) return ret &#125;&#125; 这样 通过调用_normalizeSongs方法 –&gt; createSong 来得到songs数据 开发MusicList.vue组件在props中接受变量 bgImgae songs title 在singer-detail 通过计算属性拿到title 和 bgImage ， &lt;music-list :songs=&quot;songs&quot; :title=&quot;title&quot; :bg-image=&quot;bgImage&quot;&gt;&lt;/music-list&gt; 这样就完成了父组件的singer-detail向子组件的music-list的传值 因为歌曲列表是滚动的 我们在music-list中复用了scroll组件 我们还需要编写一个song-lsit组件，为接下来所用 跳转到song-list组件开发 在music-list编写代码： 123456789101112131415&lt;scroll class=&quot;list&quot; ref=&quot;list&quot; :data=&quot;songs&quot; :probe-type=&quot;probeType&quot; :listen-scroll=&quot;listenScroll&quot; @scroll=&quot;scroll&quot;&gt; &lt;div class=&quot;song-list-wrapper&quot;&gt; &lt;song-list :songs=&quot;songs&quot;&gt;&lt;/song-list&gt; &lt;/div&gt; &lt;div class=&quot;loading-container&quot; v-show=&quot;!songs.length&quot;&gt; &lt;loading&gt;&lt;/loading&gt; &lt;/div&gt;&lt;/scroll&gt; 至此，打开页面，我们可以看到歌单列表已经可以正常滚动 1. 解决图片撑开问题 这是我们发现我们的页面上全部被歌单列表所占用， 要计算图片的位置把歌手背景图展现出来 在mounted生命周期钩子里添加 1this.$refs.list.$el.style.top = `$&#123;this.$refs.bgImage.clientHeight&#125;px` 这样就能实现歌手海报图的展示了 2. 实现海报图跟着滚动的效果我们在music-list.vue中加入一个layer层，用于跟着跟单一起滚动，来覆盖我们的bg-image，这样就能视觉上达到我们想要的效果了 &lt;div class=&quot;bg-layer&quot; ref=&quot;layer&quot;&gt;&lt;/div&gt; 监听滚动距离 为scroll组件传入probeType值和listenScroll值 1234created() &#123; this.probeType = 3 this.listenScroll = true&#125; 为scroll添加scroll方法来监听滚动距离 123scroll(pos) &#123; this.scrollY = pos.y&#125; 并监听scrollY数据 1234567891011121314151617181920212223242526272829watch: &#123; scrollY(newY) &#123; let translateY = Math.max(this.minTranslateY, newY) let zIndex = 0 let scale = 1 let blur = 0 this.$refs.layer.style[transform] = `translate3d(0, $&#123;translateY&#125;px, 0)` const percent = Math.abs(newY / this.imageHeight) if (newY &gt; 0) &#123; scale = 1 + percent zIndex = 10 &#125; else &#123; blur = Math.min(20 * percent, 20) &#125; this.$refs.filter.style[backdrop] = `blur($&#123;blur&#125;px)` if (newY &lt; this.minTranslateY) &#123; zIndex = 10 this.$refs.bgImage.style.paddingTop = 0 this.$refs.bgImage.style.height = `$&#123;RESERVED_HEIGHT&#125;px` this.$refs.pbtn.style.display = 'none' &#125; else &#123; this.$refs.bgImage.style.paddingTop = '70%' this.$refs.bgImage.style.height = 0 this.$refs.pbtn.style.display = '' &#125; this.$refs.bgImage.style.zIndex = zIndex this.$refs.bgImage.style[transform] = `scale($&#123;scale&#125;)` &#125;&#125; 3. 处理滚动到顶部的时候歌手title被歌单覆盖的问题 处理方法见上面代码zIndex相关操作 4. 下滑的时候bg-image图片放大 处理见上代码 bgImage scale相关的操作 ５. 加入loading组件 在scroll结尾复用loading 即可 开发song-list组件1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class=&quot;song-list&quot;&gt; &lt;ul v-for=&quot;(song, index) in songs&quot; :key=&quot;index&quot; class=&quot;item&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;h2 class=&quot;name&quot;&gt;&#123;&#123;song.name&#125;&#125;&lt;/h2&gt; &lt;p class=&quot;desc&quot;&gt;&#123;&#123;getDesc(song)&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=&quot;text/ecmascript-6&quot;&gt;export default &#123; props: &#123; songs: &#123; type: Array, default: () =&gt; [] &#125; &#125;, methods: &#123; getDesc(song) &#123; return `$&#123;song.singer&#125; - $&#123;song.album&#125;` &#125; &#125;&#125;&lt;/script&gt; 在music-list中传入song值 &lt;song-list :songs=&quot;songs&quot;&gt;&lt;/song-list&gt; a. Vuex什么是vuex Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 简单的说，当我们的vue项目比较复杂的时候，有的时候两个兄弟组件，或者相关度联系很低的组件相互之间需要同时获取或监听同一个数据或状态，这个时候我们就要使用vuex vuex 就像是一个大的机房，里面存着共享数据。这个房间我们可以让任何一个组件进来获取数据或者更新数据 如何使用vuex安装vuex npm install vuex --save 在项目的根目录下，我们一般会新建一个store文件夹，里面添加新建文件： 入口文件 index.js 存放状态 state.js 存放Mutations mutations.js 存放mutations相关数据的 mutation-types.js 数据修改 执行Mutations actions.js 数据映射 getters.js getters 和 vue 中的 computed 类似 , 都是用来计算 state 然后生成新的数据 ( 状态 ) 的。 以此项目为例子，需要各个组件之间共享一个singer数据 state.js 12345const state = &#123; singer: &#123;&#125;&#125;export default state mutation-types.js 1export const SET_SINGER = 'SET_SINGER' 使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然 mutations.js 12345678import * as types from './mutation-types'// import * as obj from "xxx" 会将 "xxx" 中所有 export 导出的内容组合成一个对象返回。const mutations = &#123; [types.SET_SINGER](state, singer) &#123; state.singer = singer &#125;&#125;export default mutations mutations.js 可以理解为是一个修改数据的方法的集合 getter.js 有时候我们需要从 store 中的 state 中派生出一些状态，如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。 Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 1export const singer = state =&gt; state.singer index.js 1234567891011121314151617181920import Vue from 'vue'import Vuex from 'vuex'import * as actions from './actions'import * as getters from './getters'import state from './state'import mutations from './mutations'import createLogger from 'vuex/dist/logger'Vue.use(Vuex) // 注册插件const debug = process.env.NODE_ENV !== 'production' // 线下调试的时候 debug 为 tureexport default new Vuex.Store(&#123; // new一个实例 actions, getters, state, mutations, strict: debug, // 开启严格模式，用于下面来控制是否开启插件 plugins: debug ? [createLogger()] : [] // 开启插件&#125;) main.js 在vue的main.js 中 注册 vuex 123456789import store from &apos;./store&apos;....new Vue(&#123; el: &apos;#app&apos;, render: h =&gt; h(App), router, store&#125;) 以上，vuex的初始化就完成了 singer.vue 写入 state 在组件中提交 Mutation 你可以在组件中使用 this.$store.commit(&#39;xxx&#39;) 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。 import {mapMutations} from &#39;vuex&#39; 在methods结尾添加 123...mapMutations(&#123; setSinger: 'SET_SINGER' // 将 `this.setSinger()` 映射为 `this.$store.commit('SET_SINGER')`&#125;) 通过this.setSinger(singer) 实现了对Mutations的提交 singer-detail.vue 取出state数据 引入 import {mapGetters} from &#39;vuex&#39; 在computed中 1234567computed: &#123; ...... ...mapGetters([ 'singer' // 把 `this.signer` 映射为 `this.$store.getters.singer` ])&#125; 至此，singer-detail 和 singer 之间就实现 singer 的共享了]]></content>
      <categories>
        <category>Vue</category>
        <category>Project</category>
      </categories>
      <tags>
        <tag>project</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-travel项目笔记]]></title>
    <url>%2F2018%2F08%2F12%2Fvue-travel%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[跟学一个vue实战教程，记录的笔记以及项目注意事项，细节。 vue-travel 1. 初始化项目1.1 手机显示配适minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; 阻止用户手滑发大缩小页面 1.2 初始化样式 –&gt;引入reset.css1.3 移动端多倍屏边框不准的问题 –&gt; 引入 border.css1.4 解决click延迟300ms的问题 –&gt; 引入 fastclick 库 npm install fastclick --save 在main.js中引入fastclick import fastClick from &#39;fastclick&#39; fastClick.attach(document.body)1.5 注册阿里的iconfont并创建travel项目 2. 首页的开发2.1 准备工作&amp;注意事项(1).项目中使用stylus来编写css样式npm install stylus --save npm install stylus-loader --save 要学习stylus语法 学习flex布局 rem布局的用法 (2). iconfont的使用和代码的优化 如何使用iconfont 进入iconfont官网，选择图标，加入购物车放入项目中 下载zip包并解压，把字体文件放入src/assets/styles/iconfont文件夹中把iconfont.css放在src/assets/styles中，把css中的文件路径改一下（因为此时&gt;css和字体文件不在同一目录下了，默认的css和字体文件在一个文件夹内） 在main.js中引入字体文件 import &#39;./assets/styles/iconfont.css&#39; 上述完成后，在想要使用图标的标签上加入 iconfont 类名，就可以在页面中使用 &gt;图标了，可以用每一个图标类名来引用，也可以使用编码的形式来使用，每一个图标的编码都在 iconfont官网我的项目图标里面，点击复制图标就能得到图标编码； 优化代码 有些代码的样式是多变的，我们可以将可变的css放入assets styles文件夹的varibles.styl文件中，方便以后的更爱–》改一处全部就改的效果 例如：我们的背景色就是一个可改变的css参数，我们可以在varibles.styl中定义 $bgcolor = #00bcd4 背景色而后在样式里引入这个styl文件即可@import &#39;../../../assets/styles/varibles.styl&#39;;background-color $bgcolor 但是@import文件引入的前缀非常长，在可以使用@符号可以优化此问题因为我们在webpack配置js文件中制定&#39;@&#39;: resolve(&#39;src&#39;), 制定了@就是src目录但是我们在css中引入css文件是 需要使用src的时候 要在@前面再多加一个~符号 相同的 我们的sytles文件夹多次使用 我们可以在webapck.config.js文件中定义&#39;styles&#39;: resolve(&#39;src/assets/styles&#39;),这样我们使用styles目录的时候就可以简化了 (3). 在github上创建新分支 在企业级的开发里，每一个新功能或新模块的开发都是在一个新的分支上进行开发完成后再合并到master主分支上 在github上创建仓库： Create a new repository on the command line touch README.md git init git add README.md git commit -m &quot;first commit&quot; git remote add &lt;name&gt; &lt;url&gt; git push -u origin master 在本地新建一个分支： git branch Branch1 切换到你的新分支: git checkout Branch1 将新分支发布在github上： git push origin Branch1 在本地删除一个分支： git branch -d Branch1 在github远程端删除一个分支： git push origin :Branch1 (分支名前的冒号代表删除) (4).管理分支的一些语法 查看分支 查看本地分支 12$ git branch* master 查看远程分支git branch -r 查看所有分支git branch -a 本地创建新的分支git branch [branch name] 切换到新的分支git checkout [branch name] 创建+切换分支git checkout -b [branch name]git checkout -b [branch name] 的效果相当于以下两步操作:git branch [branch name] + git checkout [branch name] 将新分支推送到githubgit push origin [branch name] orgin是你远程仓库的名字 删除本地分支git branch -d [branch name] 删除github远程分支git push origin :[branch name] 分支名前的冒号代表删除。 合并分支 123git checkout mastergit merge &lt;name&gt;/&lt;new-branch-name&gt;git push 2.2 首页轮播首页轮播图，采用vue-awesome-swiper插件 vue-awesome-swiper github npm装包 npm install vue-awesome-swiper@2.6.7 --save 使用方法和使用步骤参考官网 在swiper-slide标签里填入img属性并引入src 加入类swiper-img 在style里定义width的宽度为100% 即可适应轮播 此时的页面在网速不好的情况下会发生页面抖动 如何解决在轮播元素的最外层加一个class为wrapper的div 然后定义.wrapper的样式12345678.wrapper overflow hidden width 100% height 0 padding-bottom: 26.67% background #eee .swiper-img width 100% 这样就能把轮播图的位置保持撑起，就不会发生页面抖动了 此时，又有一个问题，我们需要导航点，怎么实现123swiperOption: &#123; pagination: &apos;.swiper-pagination&apos; &#125; 在swiperOption里添加pagination配置项就可以了 此时的导航激活状态是蓝色的 怎么更改为白色？我们可以在页面查看小原点的类名为swiper-pagination-bullet-active，我们如果直接在样式中修改这个样式的background，是达不到更改效果的，为什么，因为此时的样式是当前组件的样式，而这个小圆点属于swiper组件的样式这时，我们可以使用穿透样式来实现在样式的最前面编写如下代码12.wrapper &gt;&gt;&gt; .swiper-pagination-bullet-active background: #eee 这样，就能达到从一个组件穿刺到另一个组件的样式更改 最后 使用v-for 对图标进行列表渲染循环，把数据保存到data的swiperList对象中 2.3 图标区域页面布局初始化 git创建分支 新建icons.vue Home.vue中引入组件 图标区域逻辑实现 当页面图标大于八个 可以左右拖动 在图标元素外加入swiper-slide标签和swiper标签 2.4 首页推荐组件开发2.5 周末游组件开发3 使用ajax传递数据3.1 准备工作 vue官方推荐使用axios来完成ajax数据的请求 装包: npm install axios --save home组件中引入axios 结合vue的mouted生命周期钩子来完成请求 如果每个子组件都发送一个ajax请求来获取数据的话，一个首页就要请求多个ajax请求，会使我们的程序效率下降，我们可以在home组件请求一个ajax请求，把数据传给子组件，这样就能提高效率 怎么模拟后台的数据呢？ 因为我们页面整直接访问static文件夹,所以我们可以在static下创建一个mock文件夹，里面定影json文件来模拟后台数据 但是我们并不想提交我们的数据到github，所以我们可以在gitnore文件中排除文件 我们上线后的ajax请求地址都是基本都是相对路径’/api/下的json文件，但是此时我们的文件在static/mock文件夹中，我们可以把axios的请求地址改成我们本地的static/mock，但是这样做的话以后上线前要更改代码，这是不可取的 即使用api文件目录，又能获取到static中的文件，怎么办？ 我们可以使用vue基于webpack-dev-serve的一个配置选项来解决这个问题，在vuecli生成的config文件夹中index.js文件有一个proxyTable配置选项我们可以这样来替换我们的请求地址：12345678proxyTable: &#123; '/api': &#123; target: 'http://localhost:8080', pathRewrite: &#123; '^/api': '/static/mock' &#125; &#125; &#125; 这样，就能完美解决我们的问题了 注意，json格式的每一项的最后一项不要加带分号，这样可能会导致json数据解析失败 3.2 首页父子组件数据传递由于home组件获取json数据后，应该向子组件传递数据，这就涉及到父组件向子组件传值的问题父组件通过属性向子组件传值，子组件props接受数据123456789101112131415161718192021methods: &#123; getHomeInfo () &#123; axios.get('/api/index.json') // 返回的是一个promise对象，后面使用then .then(this.getHomeInfoSucc) // 获取成功执行getHomeInfoSucc函数 &#125;, getHomeInfoSucc (res) &#123; res = res.data if (res.ret &amp;&amp; res.data) &#123; const data = res.data this.city = data.city this.swiperList = data.swiperList this.iconList = data.iconList this.recommendList = data.recommendList this.weekendList = data.weekendList &#125; console.log(res) &#125;&#125;,mounted () &#123; this.getHomeInfo() // 页面挂载好执行这个方法ajax获取数据&#125; 3. 首页的开发3.1 初始化准备 配置路由 创建组件 3.2 header开发 创建组件 city.vue导入 3.3 搜索框 创建组件 city.vue导入 3.4 城市列表 创建组件 city.vue导入 title聊表的边框不太明显，可以给其添加样式12345.border-topbottom &amp;:before border-color #ccc &amp;:after border-color #ccc 因为我们将要使用一个滚动插件–Better-scroll来完成此页面，所以我们应该禁止页面的超出滚动1234567.list overflow hidden position absolute top 1.58rem left 0 right 0 bottom 0 使用Better-scroll 装包 npm install better-scroll –save import Bscroll from ‘better-scroll’ 在vue的mounted时挂载一个better-scroll实例 因为这个组件需要最外城的wrapper dom元素 我们给最外层标签添加ref=”wrapper”属性 3.5 字母滑动选择器 创建组件 city.vue导入 使用flex布局使其居中 3.6 ajax获取城市数据 在city.vue中引入city.json 父子间向子组件传递消息 3.7 兄弟组件联动Todo1. 点击右侧字母表 list也跳到对应的城市也部分 循环字母列表时为每一个字母绑定点击事件alphabet组件传递消息给父组件city，city在传递消息给list组件，实现Alphabet和list的兄弟传值 Alphabet.vue@click=&quot;handleLetterClick&quot; 123handleLetterClick (e) &#123; this.$emit('change', e.target.innerText) &#125;, City.vue@change=&quot;handleLetterChange&quot; 123handleLetterChange (letter) &#123; this.letter = letter &#125; :letter=&quot;letter&quot; 传递给list.vue组件 List.vueprops 接收 letter通过watch来监听letter的变化1234567891011watch: &#123; letter () &#123; // 监听letter改变 if (this.letter) &#123; const element = this.$refs[this.letter][0] // refs--&gt;通过为每个循环绑定ref ref的值对应的是每个key 也就是每个字母 // [0]--&gt;取到的是一个数组，具体的元素dom节点为数组的第一项 this.scroll.scrollToElement(element) // scroll插件的而一个方法帮我们调到制定元素 &#125; &#125;&#125; Todo2. 滑动右侧字母表，list跟着滑动到对应的位置 Alphabet.vue绑定star move end 三个触摸方法123@touchstart="handleTouchStart"@touchmove="handleTouchMove"@touchEnd="handleTouchEnd" 把字母表从cities获取放到计算属性letters中12345678910computed: &#123; letters () &#123; const letters = [] for (let i in this.cities) &#123; letters.push(i) &#125; return letters // ['A','B','C'...] &#125; &#125;, 将计算出的滑到哪个字母$emit传递给父元素1234567891011handleTouchMove (e) &#123; if (this.touchStatus) &#123; const startY = this.$refs['A'][0].offsetTop // A元素距离顶部的高度 const touchY = e.touches[0].clientY - 79 // 手指距离header下边缘的的距离 const index = Math.floor((touchY - startY) / 22) // 滑动了第几个字母 if (index &gt;= 0 &amp;&amp; index &lt; this.letters.length) &#123; this.$emit('change', this.letters[index]) &#125; // console.log(index) &#125; &#125;, City.vue@change=”handleLetterChange”接收来自Alphabet的letter:letter=&quot;letter&quot; 传递给list同样的和1一样使用watch来监视 Todo3. 列表组件优化 const startY = this.$refs[&#39;A&#39;][0].offsetTopstartY的值是固定的，可以提取出来 放在updated生命周期函数钩子中，因为刚开始加载citise是通过json获取的，刚开始获取不到的时候是空，之后有获取到了ajax的内容，页面更新，就会执行updated钩子函数 函数节流手指在屏幕上滑动的时候，函数执行的次数是非常高的，我们可以采用函数节流通过定义一个定时器，来大大提高我们代码性能123456789101112131415handleTouchMove (e) &#123; if (this.touchStatus) &#123; if (this.timer) &#123; clearTimeout(this.timer) &#125; this.timer = setTimeout(() =&gt; &#123; const touchY = e.touches[0].clientY - 79 // 手指距离header下边缘的的距离 const index = Math.floor((touchY - this.startY) / 22) // 滑动了第几个字母 if (index &gt;= 0 &amp;&amp; index &lt; this.letters.length) &#123; this.$emit('change', this.letters[index]) &#125; // console.log(index) &#125;, 10) &#125;&#125; 3.7 完善搜索框–逻辑 在search.vue增加search-content类 用于展示搜索内容1234567891011121314&lt;div class="search-content" ref="search" v-show="keyword"&gt; &lt;ul&gt; &lt;li class="search-item border-bottom" v-for="item of list" :key="item.id" &gt; &#123;&#123;item.name&#125;&#125; &lt;/li&gt; &lt;li class="search-item border-bottom" v-show="hasNoData"&gt; 没有找到匹配数据 &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; ref = search 用于在mounted挂载滚动插件 v-show=”keyword” 没有输入内容不显示 在watch中监听keyword的变化，使用循环遍历，通过筛选把符合的city追加到list数组 使用v-for循环输出list 中间使用了定时器来实现函数节流来提高性能 4.使用Vuex来实现数据共享4.1 实现city和home组件的数据联动 我们想要城市页面和首页实现数据共享City.vue和Home.vue是没有一个父组件可供中转，那么想进行两者的通信，该怎么办呢？ Vuex npm install vuex –save 在src目录下创建store文件夹并新建index.js文件 12345678910111213141516171819202122import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store(&#123; // 向外暴露一个由Actions State Mutations 三个组成的系统对象 state: &#123; city: 'aaa' &#125;, // actions: &#123; // changeCity (ctx, city) &#123; // 借助这个ctx上下文来使用commit方法来调用Mutations完成数据的更改 // console.log(city) // console.log(ctx) // ctx.commit('MchangeCity', city) // &#125; // &#125;, mutations: &#123; MchangeCity (state, city) &#123; state.city = city &#125; &#125;&#125;) 在main.js中引入import store from &#39;./store&#39; // vuex 这样我们全局都能访问到store了并在vue实例中申明store,这样，我们以后就能使用vuex的数据了 具体使用 把要公用的数据（例如city）定义到store/index.js的state中，在页面中把有city的地方换成 我们为循环的每一个城市按钮绑定一个方法 @click=&quot;handleCityClick(item.name)并在methods中定义方法: 123456methods: &#123; handleCityClick (city) &#123; this.$store.commit('MchangeCity', city) // 想要通过actions调用方法必须使用dispatch 或者 跳过actions直接通过commit来调用Mutations this.$router.push('/') // 选择后跳转到主页 实现联动 用了vue-router的编程跳转链接 &#125;&#125; 在store中定义Actions函数和Mutations函数 来实现数据的修改 总结: 想要通过vuex来管理公用数据,想要更改数据 要经过一下步骤 组件 —dispatch—&gt; Actions1234methods: &#123; handleCityClick (city) &#123; this.$store.dispatch('changeCity', city) // 想要通过actions调用方法必须使用dispatch&#125; Actions —commit—&gt; Mutations 12345actions: &#123; changeCity (ctx, city) &#123; // 借助这个ctx上下文来使用commit方法来调用Mutations完成数据的更改 ctx.commit('MchangeCity', city) &#125; &#125;, Mutations ——&gt; State 12345mutations: &#123; MchangeCity (state, city) &#123; state.city = city &#125;&#125; 在不复杂的环境下，有的时候我们更爱数据并不一定需要经过Actions，组件可以直接通过commit来使Mutations改变State 组件 —commit—&gt; Mutations 1234methods: &#123; handleCityClick (city) &#123; this.$store.commit('MchangeCity', city) // 想要通过actions调用方法必须使用dispatch&#125; Mutations ——&gt; State 12345mutations: &#123; MchangeCity (state, city) &#123; state.city = city &#125;&#125; 4.2 vuex的高级使用和localStorage 上述我们已经完成了vuex 实现两个不先练的组件的数据共享，但是我们一旦刷新我们的页面，我们的页面数据还是默认的我们在store中定义的数据，如何让程序记录我们的操作 使用localStorage来完成在Mutations定义的方法里 加入：localStorage.city = city 来记录我们选择的城市在state中city: localStorage.city || &#39;南阳&#39;这样 浏览器就能记忆我们选择的城市了 但是此时存在一个问题，浏览器如果使用了隐身模式或者关闭了浏览器存储，我们的程序就会直接报错无法执行我们可以使用try catch来优化一下我们的代码 vuex高级 慢慢的 我们的store- index中的代码越来越多，我们可以把状态分开到不同的文件中管理 使用map辅助函数来进行优化 4.3 使用keep-alive优化网页性能 路由发生切换的时候 ajax都会被重新发送，为什么？ 因为我们的页面每一次渲染都会执行mounted钩子 而我们的ajax请求就是放在mounted中进行的 怎么优化？ 将我们的router-view坑用keep-alive标签包裹起来1234567&lt;template&gt; &lt;div id="app"&gt; &lt;keep-alive&gt; &lt;router-view/&gt; &lt;/keep-alive&gt; &lt;/div&gt;&lt;/template&gt; 页面被keep-alive包裹起来，就会是页面的资源加载到内存当中，不需要重新渲染，也不需要从新执行钩子，来回返回页面也只会获取一次json此时，我们的vue中多出来一个生命周期函数钩子：activated 4.4 选择城市后返回页面 页面需要被修改 我们之前写的代码是固定的，虽然选择的城市发生变化,但是我们的我们的home页面中的内容并没有变化，怎么办？ 我们home首页的内容是有index.json ajax来获取的 我们只需要在home组件获得ajax的时候 使用？传参的方式，使得每一个城市对应自己的json文件，就可以了 axios.get(&#39;/api/index.json?city=&#39; + this.city 但是此时的json文件被缓存到了内存当中，存的还是第一次的值，我们怎么改变缓存的数据呢 由于此时的页面被keep-alive标签包裹，我们的ajax请求只会在第一次刷新的时候被获取，但是此时我们需要由城市列表选择的城市来同步我们首页的json文件以达到统一刷新的目的 keep-detail 可以加入exclude=”不被缓存的组件名字” 这样就可以指定排除某个组件不被缓存 此时我们可以使用activated生命周期钩子因为在被包裹keep-alive标签之后，mounted钩子不会执行，但是activated钩子只要页面重新出现，就会执行，所以我们可以在activated钩子函数中 判断页面选择的城市和之前的城市是否为一个城市，如果不是一个城市，则重新发送ajax请求我们在data数据中新增一个 lastcity 数据 配合activated钩子使用123456activated () &#123; if (this.lastcity !== this.city) &#123; this.lastcity = this.city this.getHomeInfo() &#125;&#125; 5.详情页面的制作创建detail.vue Banner.vue 导入detail路由 5.1 banner的制作 字体图标更新后 记得替换字体文件和iconfont.css的一段 base64的代码、 使用 background-image linear-gradient 达到渐变效果 5.2 banner画廊组件 这个画廊组件不仅仅这个组件中要使用，以后可能在别的地方也会使用 所以我们新建 src/common/gallary/Gallary.vue 编写画廊组件为以后复用 使用swiper插件实现图片轮播滚动 当我们点击banner的时候调到画廊页面，会发现渲染有问题，怎么办？点击跳转dom节点，会使得我们的css属性计算出错，从而造成错误，swiper为我们提供了一组配置，我们在配置项里添加 observeParents: true 和 observer: trueobserveParents: 将observe应用于Swiper的父元素。当Swiper的父元素变化时，例如window.resize，Swiper更新。observer: 启动动态检查器(OB/观众/观看者)，当改变swiper的样式（例如隐藏/显示）或者修改swiper的子元素时，自动初始化swiper。 5.3 渐隐逐显的header 页面有两个头部，一个是刚进去的的定位为abs的返回按钮，另外一个是定位是fixed头部导航 刚开始我们使用v-show = showAbs 和 v-show = ！showAbs 来分别控制两个头部，使其只显示一个 使用 window.addEventListener(&#39;scroll&#39;, this.handleScroll) 来监听滚动的距离以切换哪个头部的展示 这个方法放在activated钩子里 handleScroll方法使用 document.documentElement.scrollTop 监听滚动离顶部的距离 展示效果做好，剩下渐隐渐显的效果 在 fixed 的头部标签绑定样式对象 :style=&quot;opacityStyle&quot;123456789101112handleScroll () &#123; const top = document.documentElement.scrollTop if (top &gt; 60) &#123; // 过渡阶段 let opacity = top / 140 // 过渡效果 opacity = opacity &gt; 1 ? 1 : opacity this.opacityStyle = &#123; opacity &#125; this.showAbs = false &#125; else &#123; this.showAbs = true &#125; &#125; &#125; 5.4 事件绑定的相关问题我们在5.3中，使用 window.addEventListener(&#39;scroll&#39;, this.handleScroll) 来监听滚动的距离，但是这个监听方法被绑定在了全局window中，所以我们的其他页面滚动时也会执行这段代码 那么 我们怎么样才能使其只绑定在详情页呢？当我们使用keep-alive标签的时候，activated钩子函数产生的同时，也产生了一个deactivated的函数钩子，在activated绑定，在deactivated解绑即可123456activated () &#123; window.addEventListener('scroll', this.handleScroll) // 页面展示绑定&#125;,deactivated() &#123; window.removeEventListener('scroll', this.handleScroll)&#125; 5.5 递归列表组件 组件自生调用自己 5.6 ajax数据替换 我们发现，首页滑动到底部，在点击详情页面，详情页面初始状态也是在底部，怎么办？ 页面滑动 各个组件会相互影响，我们可以在路由的配置选项中添加如下配置：123scrollBehavior: function (to, from, savedPosition) &#123; return savedPosition || &#123; x: 0, y: 0 &#125;&#125; router进阶 每个组件的export defalut的name是干什么用的？ 我们目前接触到的： 递归组件中可以用到它 对某个页面取消缓存的时候 vue tools中组件的显示名字 6 Vue项目上线前准备6.1 Vue项目的接口联调 我们之前都是自己模拟后端的数据，实际项目中，我们是要和后端的数据，实现项目联调，如何进行？ 把mock中的数据替换成真正的后端服务器数据 把config index.js 中的api制定的路径改为后端服务器的地址 一般都是本地80端口，一般是一下的形式12345proxyTable: &#123; '/api': &#123; target: 'http://localhost:80' &#125;&#125; 6.2 Vue项目的真机测试我们的项目是 通过 Webpack dev server 来进行的 它默认不支持ip地址的访问方式，要把它的默认配置项修改 在package.json下 修改dev配置项 webpack-dev-server --host 0,0,0,0这样，就可以直接通过手机用ip地址来访问我们的项目 在真机上，我们拖动字母表，会发现整个页面都跟着滚动，出现了bug，怎么半？ `@touchstart.prevent=”handleTouchStart”` 组织拖动的默认行为 在低版本的安卓浏览器，可能出现白屏现象，怎么办？ 出现白屏现象的原因大部分是因为手机浏览器不支持promise特性，我们在项目中安装一个第三方的包 npm install babel-polyfill --save 在main.js引入包 import &#39;babel-polyfill&#39; 6.3 Vue项目的打包上线 运行命令 npm run build 生成一个能被浏览器运行的代码，打包完成后，项目目录中多出来一个dist文件夹，里面就是是上线代码 dist文件夹里的文件放到服务器跟目录中，就能上线了 如果想把上线文件放到根目录以外的地方，我们可以更改我们的config/index.js –&gt; build–&gt; assetsPublicPath路径 End To Dovue基础官方文档熟连掌握VueRouter 细节Vuex 细节Vue 服务器端渲染 （难）### Webpack Bable Es6]]></content>
      <categories>
        <category>Vue</category>
        <category>Project</category>
      </categories>
      <tags>
        <tag>project</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-笔记]]></title>
    <url>%2F2018%2F08%2F04%2Fvue%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近跟着慕课网老师在做一个vue-travel去哪网基础vue课程，记录下的学习笔记。 Vue一、初识Vue1.MVVM 什么是MVVM？在Vue中，写的数据方法等都属于M层 模板标签就属于V层 写的代码都是在对数据进行操作 数据变化页面对应的V层自动跟着变 这就是VM层做的（Vue就是VM层）;在Vue中 Vue作为VM层 对M层数据进行操作，数据改变后又通过VM层使数据驱动视图来改变V层，这就是数据驱动视图；使用MVVM模式来进行开发，只需要对数据M层进行修改就可以了，在Vue开发中，我们应将注意力转移到M层；使用MVP模式来开发，代码里会有很多关于DOM的操作，而使用MVVM模式来开发，Dom的操作被极大的简化了，代码量会得到显著的减少； 2.前端组件化 什么是前端组件化？组件就是页面的一个部分，我们可以把一个页面切分成很多部分，每个部分都可以称为一个组件，合理的拆分组件，可以使复杂的大型开发分成很多小的部分，便于前期开发，也便于后期维护； 二、Vue基础1.Vue实例 sass 1234567891011121314151617181920&lt;body&gt; &lt;div id="root"&gt; &lt;div @click="handleClick"&gt; `&#123;&#123;message&#125;&#125;` &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#root', data:&#123; message:'hello Vue' &#125;, methods:&#123; handleClick:function()&#123; alert('hello') &#125; &#125; &#125;)&lt;/script&gt; 每一个组件也是一个Vue实例，一个Vue项目就是很多Vue实例组成的； vm.$data可以访问data中的数据，vm.$destroy是一个可以销毁vm实例的一个方法；属性名前加 $ 代表这个属性或方法是vue实例中的属性或方法 2.Vue实例的生命周期钩子 生命周期函数就是vue实例在某一个时间点会自动执行的函数生命周期函数不放在vue实例的methods中，而是直接放在vue实例中 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;body&gt; &lt;div id="root"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; //生命周期函数就是vue实例在某一个时间点会自动执行的函数 var vm = new Vue(&#123; el: '#root', template: '&lt;div&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;', data:&#123; text:'hello' &#125;, beforeCreate() &#123; console.log("beforeCreate") &#125;, created() &#123; console.log("created") &#125;, beforeMount() &#123; console.log(this.$el) console.log("beforeMount") &#125;, mounted() &#123; console.log(this.$el) console.log("mounted") &#125;, beforeDestroy() &#123; console.log(this.$el) console.log("beforDestroy") &#125;, destroyed() &#123; console.log(this.$el) console.log("destroyed") &#125;, beforeUpdate () &#123; console.log("beforeUpdate") &#125;, updated() &#123; console.log("updated") &#125; &#125;)&lt;/script&gt; 注意：虽然vm.$destory()执行后页面中还有vm实例，并不是完全清空；但是此时的vm实例已经和页面断开连接，无法再使用vue更新视图 除了以上的八个生命周期函数，还有三个生命周期函数 activated deactivated errorCaptured 11个生命周期函数官方文档 3.Vue的模板语法 {{ }} v-text v-html v-bind v-on v-model4.计算属性，方法和侦听器 计算属性 computed 12345678910111213141516171819&lt;body&gt; &lt;div id="app"&gt; &#123;&#123;fullname&#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data:&#123; fitstname:'kong', lastname:'xiaobu' &#125;, computed: &#123; fullname: function()&#123; return this.fitstname + " " + this.lastname &#125; &#125; &#125;)&lt;/script&gt; 1.computed的每一个计算属性，都是一个方法2.每一个方法最后都必须返回一个值3.方法中调用的数据不要忘记加 this 计算属性放在内存缓存中，如果计算一次以后计算的依赖的各项都没有再发生改变，那么这个计算属性就不会再次计算，增加性能效率 方法12345678910111213141516171819&lt;body&gt; &lt;div id="app"&gt; &#123;&#123;fullname()&#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data:&#123; fitstname:'kong', lastname:'xiaobu' &#125;, methods: &#123; fullname:function()&#123; return this.fitstname+" "+this.lastname &#125; &#125; &#125;)&lt;/script&gt; 和computed都具备缓存机制，但是代码比computed复杂很多 computed计算属性，methods方法，watch侦听器都可选，但是优先选择computed 5.计算属性的setter和getter 普通的计算属性:123456&gt; computed: &#123; fullname:function()&#123; return this.fitstname + " " + this.lastname &#125; &#125;&gt; 其中其实每一个计算属性都是一个对象，对象包含着get方法（取值时调用）和set方法（改值时调用）123456789101112131415&gt; computed: &#123; fullname:&#123; get:function()&#123; return this.fitstname + " " + this.lastname &#125;, set:function(value)&#123; //这个value就是fullname被修改成的值 var arr = value.split(" ") this.fitstname = arr[0] this.lastname = arr[1] console.log(value) console.log(this.fitstname) &#125; &#125; &#125;&gt; 6.Vue中的样式绑定 面向数据的Vue怎么能修改样式呢？？ 1. Class的对象绑定 举一个例子来说明： 这里要使得div中的文字点击变色 a,绑定一个点击事件在div上 @click=&quot;handleDivClick&quot;,而后在vm实例的methods添加这个方法 b,在这个div上添加1234567891011121314151617181920 &gt;其中**activated**是在类名 **isActivated**是vm实例中data中的数据，布尔类型，当isActivated为true时，activated类作用到div上，当isActivated为false时，则不作用在div上，在style中定义activated的样式，即可实现通过vue改变数据从而间接的控制样式的改变**2. Class可以和数组绑定**还是前面的那个例子```JavaScript&lt;div @click=&quot;handleDivClick&quot; :class=&quot;[activated]&quot; &gt;------------------------------------------------ var vm = new Vue(&#123; el: &apos;#app&apos;, data:&#123; // isActivated:false activated:&quot;&quot; &#125;, methods: &#123; handleDivClick:function()&#123; this.activated = (this.activated === &quot;activated&quot; ? &quot;&quot;:&quot;activated&quot;) &#125; &#125; &#125;) 其中div class绑定的数组中，都是一个变量，这个变量可以定义在vm实例的data属性中，刚开始为空，通过handleDivClick点击函数当用户点击div后 ，通过this.activated = (this.activated === &quot;activated&quot; ? &quot;&quot;:&quot;activated&quot;)来给activated这个变量赋值，先前在style中已经定义过activated的样式，这样就能实现样式的转换 这种方法可以在数据里添加多个变量，作用于多个样式 3.直接绑定style改样式12345678910111213141516171819202122&lt;body&gt; &lt;div id="app"&gt; &lt;div :style="styleObj" @click="handleDivClick"&gt; Hello Vue &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; styleObj:&#123; color:"black" &#125; &#125;, methods: &#123; handleDivClick:function()&#123; this.styleObj.color = this.styleObj.color === "black" ? "red" : "black"; &#125; &#125; &#125;)&lt;/script&gt; 直接:style=&quot;styleObj&quot;来绑定样式 其中styleObj是一个定义在data的style样式对象 ：绑定机制就能讲样式作用与div中 如果将:style=&quot;styleObj&quot; 改为2中的数组的形式，数组的每一项都是一个style样式对象，这样就可以实现多样式的叠加 &lt;div :style=&quot;[styleObj,{fontSize:&#39;20px&#39;}]&quot; @click=&quot;handleDivClick&quot;&gt; Vue中的条件渲染 v-if v-show1234567891011121314&lt;body&gt; &lt;div id="app"&gt; &lt;div v-if="show"&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; show:true, message:"hello World" &#125; &#125;)&lt;/script&gt; v-if和v-show的区别？v-show不管页面中是否显示，他都已经渲染，只不过样式为隐藏不显示而已；而v-if如果条件不成立的话，元素节点直接在页面中移除，而不是像v-showDom节点还在页面中 如果频繁的将一些节点在页面上删除又添加的话，那么v-show相比于v-if效率更高 yo~ v-if高级使用：可以和v-else联合使用，两者一块使用必须紧贴在一起使用，中间不能夹着其他的标签 yo~12345678910111213141516&lt;body&gt; &lt;div id="app"&gt; &lt;div v-if="show"&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; &lt;div v-else&gt;Yooo&lt;/div&gt; &lt;!--亦可以使用 v-if v-else-if v-else联合使用--&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; show:true, message:"hello World" &#125; &#125;)&lt;/script&gt; 7.Vue的列表渲染12345678910111213&lt;body&gt; &lt;div id="app"&gt; &lt;div v-for="(item, index) in nums" :key="index"&gt;&#123;&#123;item&#125;&#125; --- index = &#123;&#123;index&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; nums:[1,2,3,4,5,6,8,7,6] &#125; &#125;)&lt;/script&gt; 在项目开发中，我们要给每渲染的每一项制定key值以提高性能，但是这个key值最好不要用index来指定，因为这样可能会影响dom的复用，通常在开发过程中，后端返回的json字符串对象中，往往会含有一个唯一标识符 id 我们可以拿这个id作为我们列表渲染的key值 改变渲染数组来改变页面的方法当我们尝试修改数组来改变页面的时候，我们不能使用通过数组下标添加数组的方法来实现这个目的，我们必须使用vue提供的数组更新检测的几个变异方法来实现: push() 在最后追加一项 pop() 删除最后一项 shift() 把数组的第一项删除掉 unshift() 数组第一项加入内容 splice() 对数组进行截取 sort() 对数组进行排序 reverse() 对数组进行翻转 除此之外，我们还可以改变数组的引用，也能使vue重新渲染，从而来改变页面 当我们需要为多个元素同时进行操作的时候，我们可以在这几个元素外加一个div父元素包裹着他们以进行操作，但是有的时候我们并不想额外的再加入div元素，这是我们就可以使用template 标签来代替div父元素，效果相同，但是这个标签不会再页面中渲染，非常方便 渲染一个对象时，key值就是键值对的名字，当想往对象里动态的加值，常规的方法是不会在页面中动态渲染出来的，和前方数组一样，可以改这个对象的引用，往里加数据，就能实现动态改变了 8.Vue的set方法对象中的set方法 要想动态的改变对象的渲染，也可以使用Vue的set方法 Vue.set(vm.对象名,&quot;键值对名&quot;,&quot;键值对值&quot;) set方法不但是Vue的全局方法（使用Vue.set(vm.对象名,&quot;键值对名&quot;,&quot;键值对值&quot;)来调用），也可以作为Vue的实例方法 vm.$set(vm.对象名,&quot;键值对名&quot;,&quot;键值对值&quot;) 数组中的set方法 对于数组，除了变异方法可以改变数以外，我们还可以使用数组中的set方法来操作数组的每一项12345678910111213&lt;body&gt; &lt;div id="app"&gt; &lt;div v-for="(item,key) of userInfo"&gt;&#123;&#123;item&#125;&#125; -- &#123;&#123;key&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; userInfo:[1,2,4,5,7] &#125; &#125;)&lt;/script&gt; Vue.set(vm.userInfo,1,5)或者vm.$set(vm.userInfo,2,10) 前者使得数组的第一项改为5，后者使得数组的第二项改为10 至此，我们改变数组的方法有三中方法 改变数组的引用 使用vue提供的数组变异方法 使用vue的set方法 同样的，对象的更改也可以是有两种 改变对象的引用 使用vue的set方法 三、深入理解vue的组件 组件使用中的细节点1.组件中的is属性先来看代码:12345678910111213141516171819&lt;body&gt; &lt;div id="app"&gt; &lt;table&gt; &lt;tbody&gt; &lt;row&gt;&lt;/row&gt; &lt;row&gt;&lt;/row&gt; &lt;row&gt;&lt;/row&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.component('row',&#123; template:'&lt;tr&gt;&lt;td&gt;this is a row&lt;/td&gt;&lt;/tr&gt;' &#125;) var vm = new Vue(&#123; el:'#app' &#125;)&lt;/script&gt; 我们的本意是想添加组件到tbody中生成表格，但是html规定tbody下只能是tr，所以页面渲染完成的页面是3个tr被渲染到与tbody同级的节点上，想要解决这个问题，我们可以使用组件中的is属性 123456//修改为下面的代码即可&lt;tbody&gt; &lt;tr is="row"&gt;&lt;/tr&gt; &lt;tr is="row"&gt;&lt;/tr&gt; &lt;tr is="row"&gt;&lt;/tr&gt;&lt;/tbody&gt; tbody下的tr标签 ul下的li标签，select下的option标签组件 都最好使用is属性 避免程序出现bug 2.非根组件中的data必须是一个函数 非根组件中的data必须是一个函数,必须返回一个对象，对象里包含着数据； 之所以这么设计，是因为一个组件大多数情况下要被多处调用，每一处调用时返回的数据都应该是不一样的，所以这样把data作为一个函数来返回一个对象的设计，目的是为了使每个组件都有自己的数据，避免其间的相互影响； 3.ref的使用 在某些必要的情况下 使用vue必须要操作页面中的dom ，这时就要 使用ref属性 例如： 1&lt;div ref='hello' @click="handleClick"&gt;hello vue&lt;/div&gt; 如果此时我们想通过点击事件，打印div元素中的文本内容，就要使用ref属性 我们通过添加ref=&#39;hello&#39;的方法 为dom添加一个ref属性，至此，我们就可以通过vm.$refs.hello.innerHTML来访问dom节点中的文本 vm.$refs 代表整个vm中所有的引用 其中有一个引用名为hello this.$refs.hello 就是绑定ref的dom节点 这里就是 &lt;div&gt;hello vue&lt;/div&gt; 可以使用this.$refs.hello.innerHTML来获取dom节点文本 ref同时也可以作用于组件，可以获取组件在页面的引用 还是通过举例子来说明问题 123456789101112131415161718192021222324252627282930313233343536 &lt;body&gt; &lt;div id="app"&gt; &lt;counter ref="one" @change="handleChange"&gt;&lt;/counter&gt; &lt;counter ref="two" @change="handleChange"&gt;&lt;/counter&gt; &lt;div&gt;&#123;&#123;total&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.component('counter',&#123; data:function()&#123; return &#123; number:0 &#125; &#125;, template:"&lt;div ref='hello' @click='handleClick'&gt;&#123;&#123;number&#125;&#125;&lt;/div &gt;", methods: &#123; handleClick: function () &#123; this.number++ this.$emit('change') //当组件发生改变触发change 子组件向父组件传值 &#125; &#125; &#125;) var vm = new Vue(&#123; el:'#app', data:&#123; total:0 &#125;, methods:&#123; handleChange:function()&#123; this.total = this.$refs.one.number + this.$refs.two.number // console.log(this.$refs.one.number) // console.log(this.$refs.two.number) &#125; &#125; &#125;)&lt;/script&gt; 问题：以上，定义了一个counter的计数器组件，通过点击使得自己初始为0的number自增加1，此时，我们在页面中引进了两个counter组件，又想在下面的total数据中显示两个组件的number数字之和 实现： 1.如代码定义counter组件，在methods的handleClick方法中 添加了 this.$emit(&#39;change&#39;) this.$emit用于子组件向父组件传值， this.$emit(‘change’) //当组件发生改变触发change 子组件向父组件传值 2.在子组件中绑定change事件 @change=&quot;handleChange&quot;和ref ref=&quot;one&quot; and ref=&quot;two&quot; 这里的ref就能获取每个组件的引用 从而为后续去得里面的数据打下基础 3.在父组件中添加handleChange方法 12345&gt;handleChange:function()&#123; this.total = this.$refs.one.number + this.$refs.two.number // console.log(this.$refs.one.number) // console.log(this.$refs.two.number) &#125; 这个的this.$refs.one和this.$refs.two就是页面中使用的俩个组件的引用，直接通过赋值就能使父组件data中的total值动态的变化 4.父子组件的消息传递 刚开始学这方面的知识时，我被这些父子传的迷迷糊糊，后来仔细琢磨发现，父组件向子组件传值，就是在Vue创造的实例对应的根节点中添加数据，然后再这个数据想传到组件中使用；而子组件想父组件传值就是，数据首先在组件定义部分中，我们想在我们的vue实例的根节点元素中使用这个数据；父子组建的传值关系，这样理解，对我这样的新手来说就会很好理解 单项数据流的概念 父组件可以向子组件传递参数，传递参数可以随意修改，但是子组件不能修改父组件传递过来的数据，子组件只能用，不能改 原因在于一旦传递过来的值 作为一个对象数据，可能多个子组件公用这个父组件传递过来的值，如果子组件可以任意修改其值，可能会造 成其他的bug 要想使用并修改父组件传递过来的值 我们可以在组件的data函数中 return的对象中定义一个数据number等于this.count 就相当于 复制一份副本进行修改编辑,原数据不动 父组件向子组件传递数据 父组件–&gt;子组件父组件通过属性的形式向子组件传递数据父组件通过 :count属性向子组件传递数据，子组件需要在组件添加 props 项，来接受父组件的数据props是一个数组或对象，父子间传递的所有数据都要作为数组或对象的项在props初始化 123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt; &lt;div id="app"&gt; &lt;counter :count="0"&gt;&lt;/counter&gt; &lt;counter :count="2"&gt;&lt;/counter&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var counter = &#123; props:['count'], data:function()&#123; return&#123; number: this.count &#125; &#125;, template: '&lt;div @click="handleClick"&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;', methods: &#123; handleClick:function()&#123; this.number ++ //这里能执行，但是会报错 //单项数据流的概念 //父组件可以向子组件传递参数，传递参数可以随意修改，但是子组件不能修改父组件传递过来的数据，子组件只能用，不能改 //原因在于一旦传递过来的值 作为一个对象数据，可能多个子组件公用这个父组件传递过来的值，如果子组件可以任意修改其值，可能会造成其他的bug //要想使用并修改父组件传递过来的值 我们可以在组件的data函数中 return的对象中定义一个数据number等于this.count 就相当于复制一份副本进行修改编辑,原数据不动 // &#125; &#125; &#125; var vm = new Vue(&#123; el: '#app', data: &#123; &#125;, methods: &#123; &#125;, components: &#123; counter &#125; &#125;)&lt;/script&gt; 子组件向父组件传值 子组件-&gt;父组件子组件向父组件传值是通过事件的方式来进行 在子组件的执行方法中可以通过$emit绑定事件到父组件 12345 methods: &#123; handleClick:function()&#123; this.$emit('inc',1)&#125;&#125; 然后在父组件页面的子组件标签中绑定$emit传递的事件 123&lt;counter :count="3" @inc="handleNumChange"&gt;&lt;/counter&gt;&lt;counter :count="2" @inc="handleNumChange"&gt;&lt;/counter&gt;&lt;div&gt;&#123;&#123;total&#125;&#125;&lt;/div&gt; 其中绑定属性的名字要和$emit中定义的名字保持一致，随后在父组件中就能使用子组件传递来的值了，在父组件的方法定义中的形参就是$emit中方法名的后面的项 注意：这里绑定的方法属性名不能用驼峰式命名 5.组件参数校验与非props特性组件参数校验 父组件向子组件传值的时候，我们会把传递的值在子组件的props里初始化一下，正常情况是这样props:[&#39;content&#39;]如果我们对父组件传过来的值有一定的筛选要求，我们可以将props作为对象，来增加筛选条件123456789101112131415&gt; props:&#123; //content:Number 只能是数字 //content:[Number,String] 可以是数字也可以是字符串 content:&#123; content: &#123; type: String, //数据类型 required:true, //这个content父组件中必传 default:'default value', //如果required设置为false时 默认的值为default的值 validator:function(value)&#123; //校验器 value是校验的内容 里面可以写函数 return (value.length &gt; 5) &#125; &#125; &#125;&#125;,&gt; 像如上的代码所示我们可以对props的值进行筛选复杂筛选可以使用对象来进行 type：数据类型 required：true 这个数据父组件必须传 dafault 当required为false时 可以默认一个数据值 validator 校验器 value是校验的内容 里面可以写函数，从而实现更复杂的自定义筛选规则 非props特性 什么是props特性？父组件向子组件传递，子组件的props接受数据，但是渲染节点上不显示父组件的数据属性，但是子组件能使用这个数据， 这叫props特性 什么是非props特性？父组件传值，而子组件没有props接受这个值，不去接受，子组件就不能使用这个数据；这种情况是非props特性非props特性会显示在dom属性上 6.非父子组件间的传值 如果两个组件不是父子关系，那么这两个组件该怎么传递消息呢？ 我们可以使用Vuex（后面会涉及到） 也可以使用Bus/总线，又成为发布订阅模式，观察者模式 来解决这个问题 总线-发布订阅模式：12345678910111213141516171819202122232425262728293031323334353637&lt;body&gt; &lt;div id="app"&gt; &lt;child content="dell"&gt;&lt;/child&gt; &lt;child content="lee"&gt;&lt;/child&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.prototype.bus = new Vue() //给每一个vue实例原型上都添加一个bus new的一个Vue Vue.component('child',&#123; data:function()&#123; return&#123; selfContent:this.content &#125; &#125;, props:&#123; content:String &#125;, template:"&lt;div @click='handleClick'&gt;child-&#123;&#123;selfContent&#125;&#125;&lt;/div&gt;", methods:&#123; handleClick:function()&#123; // alert(this.content) 测试 this.bus.$emit('change',this.selfContent) &#125; &#125;, mounted:function()&#123; var this_ = this this.bus.$on('change',function(msg)&#123; this_.selfContent = msg &#125;) &#125; &#125;) var vm = new Vue(&#123; el:'#app', &#125;)&lt;/script&gt; 目的：我们想要页面的两个组件点击其中的一个，另外一个就和点击的组件内容同步 这两个组件属于兄弟组件，不是父子组件的关系，如果传递消息呢？ 首先在vue的原型链上添加一个bus赋值为一个vue实例； Vue.prototype.bus = new Vue() 像父子组件传值一样父组件通过属性的形式子组件props接受数据，因为我们后续要改变这个值，所以我们把父组件传过来的值通过data函数保存一份副本供之后修改操作 在子组件上增加点击函数并在method中加以定义，函数中通过this.bus.$emit(&#39;change&#39;,this.selfContent)实现值的传递； 要增加一个mounted的生命周期函数钩子，来实现传递1234567&gt; mounted:function()&#123;&gt; var this_ = this&gt; this.bus.$on('change',function(msg)&#123;&gt; this_.selfContent = msg&gt; &#125;)&gt; &#125;&gt; change是3中定义的change，两者要保持一直，msg形参是3中的this.selfcontent 以上，一个非父子组件的传递就通过bus总线/发布订阅者模式的形式得到实现 7.在Vue中使用插槽插槽的使用场景 我们知道，父组件向子组件传值可以使用props接受消息，但是如果父组件想传给子组件一个dom结构，里面包含着很多文本内容，这是我们如果再使用props来接受父组件的属性数据，也是可以实现的，但是我们的代码质量会降低，这时，我们就可以使用Vue的插槽 12345678910111213141516171819&lt;body&gt; &lt;div id="app"&gt; &lt;child content='Yooo'&gt; &lt;p&gt;插槽内容&lt;/p&gt; &lt;/child&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.component('child',&#123; props:['content'], template:`&lt;div&gt; &lt;p&gt;hello&lt;/p&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;` &#125;) var vm = new Vue(&#123; el:'#app' &#125;)&lt;/script&gt; 如代码所示，我们在我们的父组件的child 下加入p标签内容，然后就可以在子组件中使用后&lt;slot&gt;&lt;/slot&gt;标签，标签里的内容就是child组件下插入的dom结构 但是我们有的时候插入的dom结构不止一个并且有顺序要求，这个时候我们就要使用到我们的具名插槽12345678910111213141516171819202122&gt;&lt;body&gt;&gt; &lt;div id="app"&gt;&gt; &lt;child content='Yooo'&gt;&gt; &lt;p slot="chacao1"&gt;插槽内容1&lt;/p&gt;&gt; &lt;p slot="chacao2"&gt;插槽内容2&lt;/p&gt;&gt; &lt;/child&gt;&gt; &lt;/div&gt;&gt;&lt;/body&gt;&gt;&lt;script&gt;&gt; Vue.component('child', &#123;&gt; props: ['content'],&gt; template: `&lt;div&gt;&gt; &lt;slot name='chacao1'&gt;&lt;/slot&gt;&gt; &lt;p&gt;hello&lt;/p&gt;&gt; &lt;slot name='chacao2'&gt;&lt;/slot&gt;&gt; &lt;/div&gt;`&gt; &#125;)&gt; var vm = new Vue(&#123;&gt; el: '#app'&gt; &#125;)&gt;&lt;/script&gt;&gt; 12如代码所示，我们只要在多个dom结构上添加一个插槽名字，slot=&quot;插槽名字&quot;而后我们在子组件使用的时候，只需要在slot的标签中 添加name属性，name属性与之前的插槽名字相对应，这样就可以实现精准的使用插槽中的某一个dom节点了 四、vue中的动画特效1.vue动画的原理进入动画的过程图 离开动画的过程图 我们想要增加动画效果，可以把要实现动画的内容用transiton标签包裹起来 可以给标签起一个任意的name值 原理： 进入动画： 动画执行前会向trans标签包裹的div上增加fade-enter 和 fade-enter-active 当动画运行之前一直到开始运行第一帧的时候，fade-enter 和 fade-enter-active的样式作用在页面上 当动画开始运行的时候 fade-enter这个样式类就会被vue移除 当进入动画效果结束的时候，fade-enter-active和fade-enter-to 都被vue删除 ​ 离开动画： 动画刚离开的一瞬间 fade-leave 和 fade-leave-active 作用在 div元素上 当离开动画开始执行的时候，fade-leave被vue抹除，又添加上了fade-leave-to的属性 最后当动画执行完毕的时候，fade-leave-active和fade-leave-to都被删除掉** 当进入动画的时候 v-enter-active类是一直存在的 而当离开动画的时候 v-leave-active类是一直存在的 注意： 以上的类中的fade是因为trans标签中定义的name名字为fade，当没有制定名字的时候默认为 v ​ 我们可以通过在transition标签里添加自己的类名来更改默认类名 ​ enter-active-class=&quot;active&quot; leave-active-class=&quot;leave&quot; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;style&gt; .fade-enter, .fade-leave-to&#123; opacity: 0; &#125; .fade-enter-active, .fade-leave-active&#123; transition: opacity 3s; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;transition name="fade"&gt; &lt;div v-if="show"&gt;hello vue&lt;/div&gt; &lt;/transition&gt; &lt;!-- 我们想要增加动画效果，可以把要实现动画的内容用transiton标签包裹起来 可以给标签起一个任意的name值 原理： 进入动画： 1.动画执行前会向trans标签包裹的div上增加fade-enter 和 fade-enter-active 当动画运行之前一直到开始运行第一帧的时候，fade-enter 和 fade-enter-active的样式作用在页面上 2.当动画开始运行的时候 fade-enter这个样式类就会被vue移除 3.当进入动画效果结束的时候，fade-enter-active和fade-enter-to 都被vue删除 离开动画： 1.动画刚离开的一瞬间 fade-leave 和 fade-leave-active 作用在 div元素上 2.当离开动画开始执行的时候，fade-leave被vue抹除，又添加上了fade-leave-to的属性 3.最后当动画执行完毕的时候，fade-leave-active和fade-leave-to都被删除掉 以上的类中的fade是因为trans标签中定义的name名字为fade，当没有制定名字的时候默认为 v --&gt; &lt;button @click="handleClick"&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#root', data:&#123; show:true &#125;, methods: &#123; handleClick:function()&#123; this.show = !this.show &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 2.vue中使用css动画库-animated.css动画 01我们可以知道，在transition标签中可以更改动画类的名字，我们可以结合animated.css动画来更好的工作。 animated.css官网 1234567&lt;transition name="fade" enter-active-class="animated swing" leave-active-class="animated shake" &gt; &lt;div v-if="show"&gt;hello vue&lt;/div&gt;&lt;/transition&gt; 给进出场动画加入animated的类，并选择合适的动画类名，就能轻松实现动画效果； 至此，进入和离开动画都完成，但是我们有的时候想要在页面刷新的时候就直接会产生动画，该如何实现呢？ 12345678910&gt; &lt;transition&gt; name="fade"&gt; appear&gt; enter-active-class="animated swing"&gt; leave-active-class="animated shake"&gt; appear-active-class="animated shake"&gt; &gt;&gt; &lt;div v-if="show"&gt;hello vue&lt;/div&gt;&gt; &lt;/transition&gt; 如代码所示，我们只需要在在标签中添加appear属性和一个appear-active-class类就可以了； 如果我们既想使用animate.css第三方库，有使用自己定义的transiton动画该怎么办呢？ 我们可以在enter-active-class和leave-active-class保留 fade-enter-active和fade-leave-active的类 123456789101112&gt; &lt;transition&gt; type="transition" //表示整个动画的时间与自定义的transition保持一致&gt; //：duration="&#123;enter:时间单位毫秒,leave:时间&#125;" 更改动画时间&gt; name="fade"&gt; appear&gt; enter-active-class="animated swing fade-enter-active"&gt; leave-active-class="animated shake fade-leave-active"&gt; appear-active-class="animated shake"&gt; &gt;&gt; &lt;div v-if="show"&gt;hello vue&lt;/div&gt;&gt; &lt;/transition&gt;&gt; 3.vue中的Js动画与velocity.js 不止是css能实现vue的动画效果，js也可以 transition标签上能加载很多js钩子，@before-enter @enter @after-enter @before-leave @leave @after-leave 12345678910111213141516171819202122232425262728293031323334353637&lt;body&gt; &lt;div id="root"&gt; &lt;transition name="fade" @before-enter="handleBeforeEnter" @enter="handleEnter" @after-enter="handleAfterEnter" &gt; &lt;div v-if="show"&gt;hello vue&lt;/div&gt; &lt;/transition&gt; &lt;button @click="handleClick"&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#root', data:&#123; show:true &#125;, methods: &#123; handleClick:function()&#123; this.show = !this.show &#125;, handleBeforeEnter:function(el)&#123; // el.style.color = "red" console.log("before-enter") &#125;, handleEnter:function()&#123; console.log("enter") &#125;, handleAfterEnter: function () &#123; console.log("AfterEnter") &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 输出结果： 有了几个js钩子，我们配合使用 velocity.js 来实现js动画的效果 4 vue中多个元素或组件的过渡多个dom的动画 12345678910&lt;style&gt; .fade-enter, .fade-leave-to&#123; opacity: 0; &#125; .fade-enter-active, .fade-leave-active&#123; transition:opacity 1s; &#125;&lt;/style&gt; 1234567891011121314151617181920212223242526&lt;body&gt; &lt;div id="root"&gt; &lt;transition mode="in-out" name="fade" &gt; &lt;div v-if="show" key="hello"&gt;hello vue&lt;/div&gt; &lt;div v-else key="bye"&gt;Bye Vue&lt;/div&gt; &lt;/transition&gt; &lt;button @click="handleClick"&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#root', data:&#123; show:true &#125;, methods: &#123; handleClick: function () &#123; this.show = !this.show &#125;, &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 在style中定义了入场和出场东花园以后，我们会发现，并没有动画切换的效果 因为vue的节点复用机制的原因，会使我们的动画切换失效 这个时候我们为每个dom节点加入一个key值指定，这样就能实现动画的效果了 我们还可以在transition标签上添加mode属性 in-out先进后出 out-in 先出后进 多个组件的动画 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;div id="root"&gt; &lt;transition mode="in-out" name="fade" &gt; &lt;component :is="type"&gt;&lt;/component&gt; &lt;/transition&gt; &lt;button @click="handleClick"&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; Vue.component('child',&#123; template:'&lt;div&gt;i am a child&lt;/div&gt;' &#125;) Vue.component('child-one',&#123; template:'&lt;div&gt;i am a childone&lt;/div&gt;' &#125;) var vm = new Vue(&#123; el:'#root', data:&#123; type:"child" &#125;, methods: &#123; handleClick: function () &#123; this.type = this.type === 'child'? 'child-one':'child' &#125;, &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 5.vue中列表渲染过渡动画12345678910111213141516171819202122232425&lt;body&gt; &lt;div id="root"&gt; &lt;transition-group&gt; &lt;div v-for="(item, index) in list" :key="item.id"&gt;&#123;&#123;item.title&#125;&#125;&lt;/div&gt; &lt;/transition-group&gt; &lt;button @click="handleBtnClick"&gt;Add&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var count = 0; var vm = new Vue(&#123; el: '#root', data: &#123; list: [] &#125;, methods: &#123; handleBtnClick: function () &#123; this.list.push(&#123; id: count++, title: 'hello world' &#125;) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 在要渲染的元素节点外加入transition-group标签，会使渲染的每一项都加上一个transition标签，这样就能实现每一个列表项的动画； 6.vue的动画封装五、路由 根据url的不同 给用户返回不同的页面 router-view标签显示的是当前路由地址所对应的内容 六、VuexVuex官方文档 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。 Status 存放的是共用 的数据 Actions 组件修改数据调用Actions进行异步处理或者批量操作 最后通过Mutations才能将值修改成功 有的时候也可以略过actions 直接调用Mutations来修改数据 使用vuex使用vuex 先安装 再用创代码建上图绿框中的一个系统 npm install vuex –save 在src目录下创建store文件夹并新建index.js文件 12345678910111213141516171819202122import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store(&#123; // 向外暴露一个由Actions State Mutations 三个组成的系统对象 state: &#123; city: 'aaa' &#125;, // actions: &#123; // changeCity (ctx, city) &#123; // 借助这个ctx上下文来使用commit方法来调用Mutations完成数据的更改 // console.log(city) // console.log(ctx) // ctx.commit('MchangeCity', city) // &#125; // &#125;, mutations: &#123; MchangeCity (state, city) &#123; state.city = city &#125; &#125;&#125;) 在main.js中引入import store from &#39;./store&#39; // vuex 这样我们全局都能访问到store了并在vue实例中申明store,这样，我们以后就能使用vuex的数据了 具体使用 把要公用的数据（例如city）定义到store/index.js的state中，在页面中把有city的地方换成 我们为循环的每一个城市按钮绑定一个方法 @click=&quot;handleCityClick(item.name)并在methods中定义方法: 123456methods: &#123; handleCityClick (city) &#123; this.$store.commit('MchangeCity', city) // 想要通过actions调用方法必须使用dispatch 或者 跳过actions直接通过commit来调用Mutations this.$router.push('/') // 选择后跳转到主页 实现联动 用了vue-router的编程跳转链接 &#125;&#125; 在store中定义Actions函数和Mutations函数 来实现数据的修改 总结: 想要通过vuex来管理公用数据,想要更改数据 要经过一下步骤 组件 —dispatch—&gt; Actions1234methods: &#123; handleCityClick (city) &#123; this.$store.dispatch('changeCity', city) // 想要通过actions调用方法必须使用dispatch&#125; Actions —commit—&gt; Mutations 12345actions: &#123; changeCity (ctx, city) &#123; // 借助这个ctx上下文来使用commit方法来调用Mutations完成数据的更改 ctx.commit('MchangeCity', city) &#125; &#125;, Mutations ——&gt; State 12345mutations: &#123; MchangeCity (state, city) &#123; state.city = city &#125;&#125; 在不复杂的环境下，有的时候我们更爱数据并不一定需要经过Actions，组件可以直接通过commit来使Mutations改变State 组件 —commit—&gt; Mutations 1234methods: &#123; handleCityClick (city) &#123; this.$store.commit('MchangeCity', city) // 想要通过actions调用方法必须使用dispatch&#125; Mutations ——&gt; State 12345mutations: &#123; MchangeCity (state, city) &#123; state.city = city &#125;&#125; vuex高级使用 分文件管理 map辅助函数来进行优化]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建站 - 随记。]]></title>
    <url>%2F2018%2F08%2F01%2F%E9%9A%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[I am NoobAkong~ Yo! 随记软件工程专业前端年以二十碌碌无为只能靠自己希望自己能通过努力给我爱的人幸福建此博客记录自己的学习生活也算是一个做笔记的地方有时候常想再优秀在一线城市扎根难如登天后又想既然起点已定没有任何职业比互联网更能创造可能多想无用少说多做脚踏实地把编程当做爱好想要的总会有的。]]></content>
  </entry>
</search>
